title: "Python Basics"
icon: "üêç"
flashcards:
  - question: "What are mutable objects in Python?"
    answer: "Mutable objects can be changed after creation. Common mutable types include lists, dictionaries, and sets. You can modify their contents without creating a new object"
    code_example: |
      # Lists are mutable
      my_list = [1, 2, 3]
      print(f"Original: {my_list}")
      my_list.append(4)           # Modifies the original list
      print(f"After append: {my_list}")   # [1, 2, 3, 4]
      
      my_list[0] = 99             # Change existing element
      print(f"After change: {my_list}")   # [99, 2, 3, 4]
      
      # Dictionaries are mutable
      my_dict = {"a": 1, "b": 2}
      print(f"Original dict: {my_dict}")
      my_dict["c"] = 3            # Add new key-value pair
      my_dict["a"] = 99           # Modify existing value
      print(f"Modified dict: {my_dict}")  # {"a": 99, "b": 2, "c": 3}
      
      # Sets are mutable
      my_set = {1, 2, 3}
      print(f"Original set: {my_set}")
      my_set.add(4)               # Add new element
      my_set.remove(1)            # Remove element
      print(f"Modified set: {my_set}")    # {2, 3, 4}
      
      # Multiple variables pointing to same mutable object
      list1 = [1, 2, 3]
      list2 = list1               # Both point to same list
      list1.append(4)
      print(f"list1: {list1}")    # [1, 2, 3, 4]
      print(f"list2: {list2}")    # [1, 2, 3, 4] - also changed!
      
      # To avoid this, create a copy
      list3 = [1, 2, 3]
      list4 = list3.copy()        # Create separate copy
      list3.append(4)
      print(f"list3: {list3}")    # [1, 2, 3, 4]
      print(f"list4: {list4}")    # [1, 2, 3] - unchanged

  - question: "What are immutable objects in Python?"
    answer: "Immutable objects cannot be changed after creation. Common immutable types include strings, tuples, integers, and floats. Operations create new objects instead of modifying existing ones"
    code_example: |
      # Strings are immutable
      my_string = "hello"
      print(f"Original: {my_string}")
      new_string = my_string + " world"   # Creates NEW string
      print(f"Original after concat: {my_string}")    # "hello" (unchanged)
      print(f"New string: {new_string}")              # "hello world"
      
      # Cannot modify string characters directly
      # my_string[0] = "H"          # This would raise TypeError
      
      # Tuples are immutable
      my_tuple = (1, 2, 3)
      print(f"Original tuple: {my_tuple}")
      # my_tuple[0] = 99            # This would raise TypeError
      
      # But you can create new tuples
      new_tuple = my_tuple + (4, 5)
      print(f"Original tuple: {my_tuple}")    # (1, 2, 3) - unchanged
      print(f"New tuple: {new_tuple}")        # (1, 2, 3, 4, 5)
      
      # Numbers are immutable
      x = 10
      y = x
      x = x + 5                   # Creates new integer, assigns to x
      print(f"x: {x}")            # 15
      print(f"y: {y}")            # 10 (unchanged)
      
      # String methods return new strings
      text = "Hello World"
      upper_text = text.upper()   # Returns new string
      print(f"Original: {text}")  # "Hello World" (unchanged)
      print(f"Upper: {upper_text}")   # "HELLO WORLD"
      
      # Immutable objects are safe to share
      tuple1 = (1, 2, 3)
      tuple2 = tuple1             # Both point to same tuple
      # Since tuples are immutable, we can't accidentally modify them
      # Any "changes" would create new objects

  - question: "What happens when you try to modify immutable objects?"
    answer: "Attempting to modify immutable objects raises a TypeError. However, operations that seem to 'modify' them actually create new objects, leaving the original unchanged"
    code_example: |
      # Trying to modify string characters
      text = "hello"
      try:
          text[0] = "H"           # Attempt to modify
      except TypeError as e:
          print(f"Error: {e}")    # 'str' object does not support item assignment
      
      # Trying to modify tuple elements
      coordinates = (10, 20)
      try:
          coordinates[0] = 15     # Attempt to modify
      except TypeError as e:
          print(f"Error: {e}")    # 'tuple' object does not support item assignment
      
      # String operations create NEW objects
      original = "python"
      result1 = original.upper()          # Creates new string
      result2 = original.replace("p", "P") # Creates new string
      result3 = original + " rocks"       # Creates new string
      
      print(f"Original: {original}")      # "python" (unchanged)
      print(f"Upper: {result1}")          # "PYTHON"
      print(f"Replace: {result2}")        # "Python"
      print(f"Concat: {result3}")         # "python rocks"
      
      # Demonstrating object identity
      numbers = (1, 2, 3)
      new_numbers = numbers + (4,)        # Creates new tuple
      
      print(f"Original ID: {id(numbers)}")     # Memory address
      print(f"New ID: {id(new_numbers)}")      # Different memory address
      print(f"Are they the same object? {numbers is new_numbers}")  # False
      
      # This applies to all immutable types
      x = 42
      y = x + 1                           # Creates new integer
      print(f"x ID: {id(x)}")
      print(f"y ID: {id(y)}")             # Different ID
      
      # Important: Even with same value, might be different objects
      a = 1000
      b = 1000
      print(f"a == b: {a == b}")          # True (same value)
      print(f"a is b: {a is b}")          # Might be False (different objects)
      
      # Small integers are cached (special case)
      c = 5
      d = 5
      print(f"c is d: {c is d}")          # True (Python caches small integers)

  - question: "What is Python's self parameter in class methods?"
    answer: "A reference to the current instance of the class, allowing access to instance variables and methods"
    code_example: |
      class Dog:
          def __init__(self, name, breed):
              self.name = name      # Instance variable
              self.breed = breed    # Instance variable
          
          def bark(self):
              return f"{self.name} says Woof!"
          
          def get_info(self):
              return f"{self.name} is a {self.breed}"
          
          def change_name(self, new_name):
              self.name = new_name  # Modify instance variable
      
      my_dog = Dog("Buddy", "Golden Retriever")
      print(my_dog.bark())        # Buddy says Woof!
      print(my_dog.get_info())    # Buddy is a Golden Retriever
      my_dog.change_name("Max")
      print(my_dog.bark())        # Max says Woof!

  - question: "What is list slicing in Python?"
    answer: "A way to extract a portion of a list using [start:stop:step] syntax"
    code_example: |
      numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
      
      # Basic slicing
      print(numbers[2:7])     # [2, 3, 4, 5, 6]
      print(numbers[:5])      # [0, 1, 2, 3, 4]
      print(numbers[5:])      # [5, 6, 7, 8, 9]
      print(numbers[:])       # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] (copy)
      
      # Step slicing
      print(numbers[::2])     # [0, 2, 4, 6, 8] (every 2nd element)
      print(numbers[1::2])    # [1, 3, 5, 7, 9] (every 2nd starting from 1)
      print(numbers[::-1])    # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] (reverse)
      
      # Negative indices
      print(numbers[-3:])     # [7, 8, 9] (last 3 elements)
      print(numbers[:-2])     # [0, 1, 2, 3, 4, 5, 6, 7] (all but last 2)

  - question: "What are Python sets and how do you create them?"
    answer: "Sets are unordered collections of unique elements. Create sets using curly braces {} or the set() function. Sets automatically remove duplicates and are useful for unique data"
    code_example: |
      # Creating sets with curly braces
      fruits = {"apple", "banana", "orange"}
      numbers = {1, 2, 3, 4, 5}
      
      # Creating sets from lists (removes duplicates)
      list_with_duplicates = [1, 2, 3, 2, 1, 4, 3]
      unique_numbers = set(list_with_duplicates)
      print(unique_numbers)           # {1, 2, 3, 4}
      
      # Creating empty set (must use set(), not {})
      empty_set = set()               # Correct
      # empty_dict = {}               # This creates a dictionary, not a set!
      
      # Converting string to set
      letters = set("hello")          # {'h', 'e', 'l', 'o'} - duplicates removed
      
      # Sets vs Lists comparison
      my_list = [1, 2, 3, 2, 1]      # [1, 2, 3, 2, 1] - keeps duplicates
      my_set = {1, 2, 3, 2, 1}       # {1, 2, 3} - removes duplicates
      
      # Key differences:
      # - Sets: unordered, unique elements, no indexing
      # - Lists: ordered, allows duplicates, supports indexing
      
      # Membership testing (very fast in sets)
      print("apple" in fruits)        # True
      print(2 in numbers)             # True

  - question: "What are mathematical set operations in Python?"
    answer: "Sets support mathematical operations like union (combine), intersection (common elements), difference (elements in first but not second), and symmetric difference (elements in either but not both)"
    code_example: |
      set1 = {1, 2, 3, 4, 5}
      set2 = {4, 5, 6, 7, 8}
      
      # Union - all elements from both sets
      union_result = set1.union(set2)
      print(union_result)             # {1, 2, 3, 4, 5, 6, 7, 8}
      # Alternative syntax: set1 | set2
      
      # Intersection - elements common to both sets
      intersection_result = set1.intersection(set2)
      print(intersection_result)      # {4, 5}
      # Alternative syntax: set1 & set2
      
      # Difference - elements in first set but not in second
      difference_result = set1.difference(set2)
      print(difference_result)        # {1, 2, 3}
      # Alternative syntax: set1 - set2
      
      # Symmetric difference - elements in either set but not in both
      sym_diff_result = set1.symmetric_difference(set2)
      print(sym_diff_result)          # {1, 2, 3, 6, 7, 8}
      # Alternative syntax: set1 ^ set2
      
      # Subset and superset checks
      small_set = {2, 3}
      print(small_set.issubset(set1))     # True (all elements of small_set are in set1)
      print(set1.issuperset(small_set))   # True (set1 contains all elements of small_set)
      
      # Disjoint sets (no common elements)
      set3 = {10, 11, 12}
      print(set1.isdisjoint(set3))    # True (no common elements)

  - question: "What are common set methods for adding and removing elements?"
    answer: "Use add() to add single elements, update() to add multiple elements, remove() to delete (raises error if not found), and discard() to delete safely (no error if not found)"
    code_example: |
      fruits = {"apple", "banana", "orange"}
      
      # Adding single element
      fruits.add("grape")
      print(fruits)                   # {"apple", "banana", "orange", "grape"}
      
      # Adding multiple elements
      fruits.update(["kiwi", "mango"])
      print(fruits)                   # Adds both kiwi and mango
      
      # Can also update with another set
      tropical = {"pineapple", "coconut"}
      fruits.update(tropical)
      
      # Removing elements - remove() raises KeyError if not found
      fruits.remove("banana")
      print(fruits)                   # banana is removed
      
      # Safe removal - discard() doesn't raise error if not found
      fruits.discard("strawberry")    # No error even though strawberry isn't in set
      fruits.discard("apple")         # Removes apple if present
      
      # Remove and return arbitrary element
      if fruits:                      # Check if set is not empty
          removed_fruit = fruits.pop()
          print(f"Removed: {removed_fruit}")
      
      # Clear all elements
      backup_fruits = fruits.copy()   # Make a copy first
      fruits.clear()
      print(fruits)                   # set() - empty set
      
      # Length and membership
      fruits = backup_fruits
      print(len(fruits))              # Number of elements
      print("apple" in fruits)        # Membership test (very fast)

  - question: "What is basic exception handling with try/except in Python?"
    answer: "Exception handling lets you catch and handle errors gracefully instead of crashing. Use try to test code and except to handle specific errors that might occur"
    code_example: |
      # Basic try/except structure
      try:
          result = 10 / 0          # This will cause an error
      except ZeroDivisionError:
          print("Cannot divide by zero!")
          result = 0               # Provide a default value
      
      # Catching any exception
      try:
          number = int("abc")      # This will cause ValueError
      except Exception as e:
          print(f"An error occurred: {e}")
      
      # Specific error handling
      try:
          my_list = [1, 2, 3]
          print(my_list[10])       # IndexError: list index out of range
      except IndexError:
          print("List index is out of range")
      
      # File handling with exception
      try:
          with open("nonexistent.txt", "r") as file:
              content = file.read()
      except FileNotFoundError:
          print("File not found!")
          content = ""             # Default content
      
      # User input validation
      try:
          age = int(input("Enter your age: "))
          print(f"You are {age} years old")
      except ValueError:
          print("Please enter a valid number")

  - question: "How do you handle multiple exception types in Python?"
    answer: "You can handle multiple exception types using multiple except blocks for different errors, or catch multiple exceptions in one block using a tuple"
    code_example: |
      # Multiple except blocks for different error types
      try:
          user_input = input("Enter a number: ")
          number = int(user_input)
          result = 100 / number
          print(f"Result: {result}")
      except ValueError:
          print("That's not a valid number!")
      except ZeroDivisionError:
          print("Cannot divide by zero!")
      except Exception as e:
          print(f"Unexpected error: {e}")
      
      # Catching multiple exceptions in one block
      try:
          data = input("Enter data: ")
          value = int(data)
          result = 10 / value
      except (ValueError, TypeError):
          print("Invalid data type entered")
      except ZeroDivisionError:
          print("Division by zero not allowed")
      
      # More specific handling
      def safe_division(a, b):
          try:
              return a / b
          except TypeError:
              print("Both values must be numbers")
              return None
          except ZeroDivisionError:
              print("Cannot divide by zero")
              return None
          except Exception as e:
              print(f"Unexpected error: {e}")
              return None
      
      # Usage examples
      print(safe_division(10, 2))    # 5.0
      print(safe_division(10, 0))    # None (with error message)
      print(safe_division("10", 2))  # None (with error message)

  - question: "What are else and finally blocks in exception handling?"
    answer: "The else block runs only if no exceptions occurred in the try block. The finally block always runs, regardless of whether an exception occurred or not"
    code_example: |
      # else block - runs only when no exceptions occur
      try:
          number = int(input("Enter a number: "))
          result = 100 / number
      except ValueError:
          print("Invalid number format")
      except ZeroDivisionError:
          print("Cannot divide by zero")
      else:
          print(f"Success! Result is {result}")  # Only runs if no exceptions
      
      # finally block - always runs
      try:
          file = open("data.txt", "r")
          data = file.read()
      except FileNotFoundError:
          print("File not found")
          data = None
      else:
          print("File read successfully")
      finally:
          try:
              file.close()         # Always try to close the file
              print("File closed")
          except:
              print("File was not opened")
      
      # Complete example with all blocks
      def process_file(filename):
          file = None
          try:
              print("Opening file...")
              file = open(filename, "r")
              content = file.read()
              print("Processing content...")
              # Simulate processing
              lines = content.split('\n')
          except FileNotFoundError:
              print("Error: File not found")
              return None
          except PermissionError:
              print("Error: Permission denied")
              return None
          else:
              print("File processed successfully")
              return lines
          finally:
              if file:
                  file.close()
                  print("File closed")
              print("Cleanup completed")
      
      # The finally block is especially useful for:
      # - Closing files
      # - Cleaning up resources
      # - Logging operations
      # - Database connections

  - question: "How do you raise custom exceptions in Python?"
    answer: "Use the 'raise' keyword to manually trigger exceptions. You can raise built-in exceptions with custom messages or create your own exception classes"
    code_example: |
      # Raising built-in exceptions with custom messages
      def validate_age(age):
          if not isinstance(age, int):
              raise TypeError("Age must be an integer")
          if age < 0:
              raise ValueError("Age cannot be negative")
          if age > 150:
              raise ValueError("Age seems unrealistic")
          return age
      
      # Using the function
      try:
          valid_age = validate_age(25)
          print(f"Valid age: {valid_age}")
      except (TypeError, ValueError) as e:
          print(f"Invalid age: {e}")
      
      # Raising exceptions in different scenarios
      def withdraw_money(balance, amount):
          if amount <= 0:
              raise ValueError("Amount must be positive")
          if amount > balance:
              raise ValueError("Insufficient funds")
          return balance - amount
      
      def divide_numbers(a, b):
          if b == 0:
              raise ZeroDivisionError("Cannot divide by zero")
          return a / b
      
      # Creating custom exception classes
      class CustomError(Exception):
          """Custom exception for demonstration"""
          pass
      
      class InvalidPasswordError(Exception):
          """Raised when password doesn't meet requirements"""
          def __init__(self, message="Password does not meet requirements"):
              self.message = message
              super().__init__(self.message)
      
      def check_password(password):
          if len(password) < 8:
              raise InvalidPasswordError("Password must be at least 8 characters")
          if not any(c.isdigit() for c in password):
              raise InvalidPasswordError("Password must contain at least one digit")
          return True
      
      # Using custom exceptions
      try:
          check_password("abc")
      except InvalidPasswordError as e:
          print(f"Password error: {e}")
      
      # Re-raising exceptions
      def risky_operation():
          try:
              result = 1 / 0
          except ZeroDivisionError:
              print("Logging the error...")
              raise  # Re-raise the same exception

  - question: "What is the difference between == and is in Python?"
    answer: "== compares values for equality, while is compares object identity (memory location)"
    code_example: |
      a = [1, 2, 3]
      b = [1, 2, 3]
      c = a
      
      print(a == b)  # True (same values)
      print(a is b)  # False (different objects)
      print(a is c)  # True (same object)
      
      # With immutable objects
      x = 1000
      y = 1000
      print(x == y)  # True (same values)
      print(x is y)  # False (different objects for large numbers)
      
      # Small integers are cached
      x = 5
      y = 5
      print(x is y)  # True (Python caches small integers)

  - question: "What is the difference between an expression and a statement in Python?"
    answer: "An expression produces a value and can be used wherever a value is expected, while a statement performs an action and doesn't return a value"
    code_example: |
      # EXPRESSIONS (produce values):
      5 + 3                    # Returns 8
      len("hello")             # Returns 5
      x > 10                   # Returns True or False
      "Hello " + "World"       # Returns "Hello World"
      
      # STATEMENTS (perform actions):
      print("Hello")           # Prints text, returns None
      x = 5                    # Assigns value, returns None
      if x > 0:                # Controls flow, returns None
          print("positive")
      
      # Expressions can be part of statements:
      result = 5 + 3           # 5 + 3 is expression, whole line is statement
      print(len("hello"))      # len("hello") is expression inside print statement

  - question: "What does it mean to 'assign' a value to a variable?"
    answer: "Assignment means storing a value in a variable using the = operator, giving the variable a name you can use to access that value later"
    code_example: |
      # Basic assignment
      name = "Alice"           # Assigns string "Alice" to variable name
      age = 25                 # Assigns integer 25 to variable age
      
      # The variable name is on the left, value on the right
      score = 95
      is_passing = True
      
      # You can reassign variables
      score = 87               # Changes score from 95 to 87
      
      # You can assign one variable to another
      old_score = score        # old_score now has the value 87
      
      # Multiple assignment
      x, y = 10, 20           # x gets 10, y gets 20

  - question: "What are the basic arithmetic operators for addition, subtraction, and multiplication in Python?"
    answer: "The basic operators are: + (addition), - (subtraction), and * (multiplication). These work with numbers and follow standard mathematical rules"
    code_example: |
      # Basic arithmetic operations
      a = 10
      b = 3
      
      addition = a + b         # 13
      subtraction = a - b      # 7
      multiplication = a * b   # 30
      
      # Works with different number types
      x = 5.5
      y = 2
      
      float_add = x + y        # 7.5
      float_sub = x - y        # 3.5
      float_mult = x * y       # 11.0
      
      # Order of operations applies
      result = 2 + 3 * 4       # 14 (multiplication first)
      result = (2 + 3) * 4     # 20 (parentheses first)

  - question: "What are the division operators in Python and how do they differ?"
    answer: "Python has two division operators: / (regular division) always returns a float, while // (floor division) rounds down to the nearest integer"
    code_example: |
      a = 10
      b = 3
      
      # Regular division (/) - always returns float
      regular_div = a / b      # 3.3333333333333335
      even_div = 10 / 5        # 2.0 (still a float)
      
      # Floor division (//) - rounds down to integer
      floor_div = a // b       # 3 (rounds down)
      negative_floor = -10 // 3  # -4 (rounds down, not towards zero)
      
      # With floats
      float_regular = 10.7 / 3   # 3.566666666666667
      float_floor = 10.7 // 3    # 3.0 (still rounds down)
      
      # Common use case: getting whole number of groups
      items = 23
      per_group = 5
      groups = items // per_group  # 4 complete groups

  - question: "What are the modulo and exponentiation operators in Python?"
    answer: "The modulo operator % gives the remainder after division, and ** is exponentiation (raising to a power)"
    code_example: |
      # Modulo operator (%) - remainder after division
      a = 10
      b = 3
      
      remainder = a % b        # 1 (10 divided by 3 = 3 remainder 1)
      
      # Common uses for modulo
      # Check if number is even or odd
      number = 7
      if number % 2 == 0:
          print("Even")
      else:
          print("Odd")        # This will print
      
      # Cycle through values
      for i in range(10):
          day = i % 7          # Cycles: 0,1,2,3,4,5,6,0,1,2...
      
      # Exponentiation operator (**)
      base = 2
      power = 3
      result = base ** power   # 8 (2 to the power of 3)
      
      # More examples
      square = 5 ** 2          # 25
      cube = 4 ** 3            # 64
      sqrt = 9 ** 0.5          # 3.0 (square root)

  - question: "What are the equality comparison operators in Python?"
    answer: "The equality operators are == (equal to) and != (not equal to). They compare values and return True or False"
    code_example: |
      # Equality operators
      x = 5
      y = 10
      z = 5
      
      # Equal to (==)
      print(x == y)          # False (5 is not equal to 10)
      print(x == z)          # True (5 equals 5)
      
      # Not equal to (!=)
      print(x != y)          # True (5 is not equal to 10)
      print(x != z)          # False (5 equals 5)
      
      # Works with different data types
      name1 = "Alice"
      name2 = "Alice"
      name3 = "Bob"
      
      print(name1 == name2)   # True
      print(name1 != name3)   # True
      
      # Common use in conditions
      password = "secret"
      if password == "secret":
          print("Access granted")

  - question: "What are the magnitude comparison operators in Python?"
    answer: "The magnitude operators are < (less than), > (greater than), <= (less than or equal), and >= (greater than or equal). They compare the size or order of values"
    code_example: |
      # Magnitude comparison operators
      x = 5
      y = 10
      z = 5
      
      # Less than (<)
      print(x < y)           # True (5 is less than 10)
      print(y < x)           # False (10 is not less than 5)
      
      # Greater than (>)
      print(y > x)           # True (10 is greater than 5)
      print(x > y)           # False (5 is not greater than 10)
      
      # Less than or equal (<=)
      print(x <= y)          # True (5 is less than 10)
      print(x <= z)          # True (5 equals 5)
      
      # Greater than or equal (>=)
      print(y >= x)          # True (10 is greater than 5)
      print(x >= z)          # True (5 equals 5)
      
      # Common use cases
      age = 18
      if age >= 18:
          print("Can vote")
      
      score = 85
      if score >= 90:
          print("A grade")
      elif score >= 80:
          print("B grade")

  - question: "How does the 'and' logical operator work in Python?"
    answer: "The 'and' operator returns True only if both conditions are True. If either condition is False, the result is False"
    code_example: |
      # AND operator - both conditions must be True
      age = 25
      has_license = True
      has_car = False
      
      # Both conditions True
      can_drive = age >= 18 and has_license    # True (25 >= 18 is True AND has_license is True)
      
      # One condition False
      can_drive_own_car = has_license and has_car  # False (has_license is True AND has_car is False)
      
      # Both conditions False
      is_young_and_unlicensed = age < 18 and not has_license  # False
      
      # Common use cases
      username = "admin"
      password = "secret"
      if username == "admin" and password == "secret":
          print("Login successful")
      
      # Multiple conditions
      score = 85
      attendance = 95
      if score >= 80 and attendance >= 90:
          print("Student passes with honors")

  - question: "How does the 'or' logical operator work in Python?"
    answer: "The 'or' operator returns True if at least one condition is True. It only returns False if both conditions are False"
    code_example: |
      # OR operator - at least one condition must be True
      age = 16
      has_permit = True
      has_license = False
      
      # One condition True
      can_practice_drive = has_permit or has_license  # True (has_permit is True)
      
      # Both conditions True
      age = 25
      has_license = True
      can_drive = age >= 18 or has_license  # True (both are True)
      
      # Both conditions False
      age = 15
      has_license = False
      can_drive_alone = age >= 18 or has_license  # False (both are False)
      
      # Common use cases
      day = "Saturday"
      if day == "Saturday" or day == "Sunday":
          print("It's weekend!")
      
      # Alternative conditions
      payment_method = "credit"
      if payment_method == "cash" or payment_method == "credit":
          print("Payment accepted")

  - question: "How does the 'not' logical operator work in Python?"
    answer: "The 'not' operator reverses a boolean value: 'not True' becomes False, and 'not False' becomes True"
    code_example: |
      # NOT operator - reverses boolean values
      is_logged_in = True
      is_guest = not is_logged_in        # False
      
      has_permission = False
      access_denied = not has_permission  # True
      
      # Common use with conditions
      age = 15
      is_adult = age >= 18               # False
      is_minor = not is_adult            # True
      
      # Use with if statements
      username = ""
      if not username:                   # True if username is empty
          print("Please enter a username")
      
      # Checking for empty collections
      items = []
      if not items:                      # True if list is empty
          print("No items found")
      
      # Double negative (not recommended but valid)
      is_valid = True
      is_invalid = not is_valid          # False
      is_valid_again = not is_invalid    # True
      
      # Combining with other operators
      has_account = True
      is_banned = False
      can_login = has_account and not is_banned  # True

  - question: "What is the difference between = and == in Python?"
    answer: "= is the assignment operator that stores a value in a variable, while == is the equality operator that compares two values and returns True or False"
    code_example: |
      # Assignment operator (=)
      x = 5                    # Assigns the value 5 to variable x
      name = "Alice"           # Assigns the string "Alice" to variable name
      
      # Equality operator (==)
      result = x == 5          # Compares x with 5, returns True
      result = name == "Bob"   # Compares name with "Bob", returns False
      
      # Common mistake - using = instead of ==
      # if x = 5:              # ERROR! This is assignment, not comparison
      if x == 5:               # CORRECT! This compares x with 5
          print("x equals 5")
      
      # Assignment vs comparison in context
      y = 10                   # Assignment: store 10 in y
      if y == 10:              # Comparison: check if y equals 10
          print("y is 10")

  - question: "What is variable naming and what are the rules?"
    answer: "Variable naming is choosing names for variables. Rules: start with letter or underscore, contain only letters/numbers/underscores, case-sensitive, no Python keywords"
    code_example: |
      # Valid variable names
      name = "Alice"
      age_in_years = 25
      _private_var = "secret"
      user1 = "first user"
      firstName = "Alice"      # camelCase
      first_name = "Alice"     # snake_case (preferred in Python)
      
      # Invalid variable names
      # 1name = "invalid"      # Can't start with number
      # first-name = "invalid" # Can't contain hyphens
      # class = "invalid"      # Can't use Python keywords
      
      # Case sensitivity
      Name = "Alice"           # Different from 'name'
      NAME = "ALICE"           # Different from 'Name' and 'name'
      
      # Good naming practices
      user_count = 10          # Descriptive name
      total_price = 99.99      # Clear purpose
      is_logged_in = True      # Boolean with is/has prefix

  - question: "How do you define a function in Python?"
    answer: "Use the 'def' keyword followed by the function name, parentheses for parameters, a colon, and an indented code block"
    code_example: |
      # Basic function definition
      def greet():
          print("Hello, World!")
      
      # Function with parameters
      def greet_person(name):
          print(f"Hello, {name}!")
      
      # Function with multiple parameters
      def add_numbers(a, b):
          result = a + b
          return result
      
      # Function with default parameter
      def greet_with_title(name, title="Mr."):
          print(f"Hello, {title} {name}!")
      
      # Function structure:
      # def function_name(parameters):
      #     function body
      #     return value (optional)

  - question: "How do you call (invoke) a function in Python?"
    answer: "Type the function name followed by parentheses, including any required arguments inside the parentheses"
    code_example: |
      # Define functions first
      def say_hello():
          print("Hello!")
      
      def greet_person(name):
          print(f"Hello, {name}!")
      
      def add_numbers(a, b):
          return a + b
      
      # Call functions
      say_hello()                    # Calls function with no parameters
      greet_person("Alice")          # Calls function with one argument
      result = add_numbers(5, 3)     # Calls function and stores return value
      
      # You can call functions multiple times
      say_hello()
      say_hello()
      
      # Function calls can be part of expressions
      total = add_numbers(10, 20) + add_numbers(5, 15)

  - question: "What are function parameters and arguments?"
    answer: "Parameters are variables in the function definition that accept values. Arguments are the actual values passed to the function when it's called"
    code_example: |
      # Parameters are in the function definition
      def calculate_area(length, width):    # length and width are parameters
          area = length * width
          return area
      
      # Arguments are passed when calling the function
      room_area = calculate_area(10, 12)    # 10 and 12 are arguments
      
      # Different ways to pass arguments:
      
      # Positional arguments (order matters)
      result = calculate_area(5, 8)         # length=5, width=8
      
      # Keyword arguments (order doesn't matter)
      result = calculate_area(width=8, length=5)  # Same as above
      
      # Mixed (positional first, then keyword)
      result = calculate_area(5, width=8)   # length=5, width=8

  - question: "What does 'return' do in a function?"
    answer: "The 'return' statement ends function execution and sends a value back to the caller. If no return statement is used, the function returns None"
    code_example: |
      # Function that returns a value
      def multiply(a, b):
          result = a * b
          return result          # Returns the calculated value
      
      # Function that returns early
      def check_positive(number):
          if number > 0:
              return True        # Exits function here if positive
          return False          # Only reached if number is not positive
      
      # Function with no return statement
      def print_message(msg):
          print(msg)            # Prints but doesn't return anything
          # Implicitly returns None
      
      # Using returned values
      product = multiply(4, 5)   # product gets the value 20
      is_pos = check_positive(7) # is_pos gets the value True
      nothing = print_message("Hi") # nothing gets None
      
      # You can return multiple values
      def get_name_age():
          return "Alice", 25     # Returns a tuple
      
      name, age = get_name_age() # Unpacks the returned tuple

  - question: "What are default parameters in functions?"
    answer: "Default parameters have preset values that are used if no argument is provided for that parameter when calling the function"
    code_example: |
      # Function with default parameters
      def greet(name, greeting="Hello", punctuation="!"):
          message = f"{greeting}, {name}{punctuation}"
          print(message)
      
      # Different ways to call with defaults
      greet("Alice")                          # "Hello, Alice!"
      greet("Bob", "Hi")                      # "Hi, Bob!"
      greet("Charlie", "Hey", ".")            # "Hey, Charlie."
      greet("Diana", punctuation="?")         # "Hello, Diana?"
      
      # Default parameters must come after regular parameters
      def create_user(name, email, role="user", active=True):
          return {
              "name": name,
              "email": email,
              "role": role,
              "active": active
          }
      
      # Call with minimum required arguments
      user1 = create_user("Alice", "alice@email.com")
      
      # Call with some optional arguments
      user2 = create_user("Bob", "bob@email.com", "admin")

  - question: "What is variable scope in functions?"
    answer: "Variable scope determines where variables can be accessed. Variables defined inside a function are local (only accessible within that function), while variables defined outside are global"
    code_example: |
      # Global variable
      global_var = "I'm global"
      
      def my_function():
          # Local variable
          local_var = "I'm local"
          
          # Can access global variable
          print(global_var)      # Works: prints "I'm global"
          print(local_var)       # Works: prints "I'm local"
      
      # Outside the function
      print(global_var)          # Works: prints "I'm global"
      # print(local_var)         # ERROR! local_var doesn't exist here
      
      # Function parameters are local variables
      def greet(name):           # 'name' is local to this function
          message = f"Hello, {name}"  # 'message' is also local
          return message
      
      # Variables with same name in different scopes
      x = 10                     # Global x
      
      def change_x():
          x = 20                 # Local x (doesn't change global x)
          print(f"Inside function: {x}")  # Prints 20
      
      change_x()
      print(f"Outside function: {x}")     # Prints 10

  - question: "What is the difference between print() and return in functions?"
    answer: "print() displays output to the screen but doesn't send data back to the caller. return sends data back to the caller but doesn't display anything"
    code_example: |
      # Function that prints
      def print_sum(a, b):
          result = a + b
          print(result)          # Displays the result
          # No return statement, so returns None
      
      # Function that returns
      def calculate_sum(a, b):
          result = a + b
          return result          # Sends result back to caller
      
      # Function that does both
      def print_and_return_sum(a, b):
          result = a + b
          print(f"The sum is: {result}")  # Displays message
          return result                   # Also returns the value
      
      # Using the functions
      print_sum(3, 4)                    # Prints "7", returns None
      x = print_sum(3, 4)                # Prints "7", x becomes None
      
      y = calculate_sum(3, 4)            # Nothing printed, y becomes 7
      print(y)                           # Now prints "7"
      
      z = print_and_return_sum(3, 4)     # Prints "The sum is: 7", z becomes 7

  - question: "What is a for loop and when do you use it?"
    answer: "A for loop repeats code for each item in a sequence (like a list or string) or for a specific number of times. Use it when you know how many times to repeat or want to process each item in a collection"
    code_example: |
      # Loop through a list
      fruits = ["apple", "banana", "orange"]
      for fruit in fruits:
          print(f"I like {fruit}")
      
      # Loop through a string
      for letter in "hello":
          print(letter)           # Prints h, e, l, l, o
      
      # Loop a specific number of times
      for i in range(5):
          print(f"Count: {i}")    # Prints 0, 1, 2, 3, 4
      
      # Loop with start and end
      for i in range(2, 6):
          print(i)                # Prints 2, 3, 4, 5
      
      # Loop with step
      for i in range(0, 10, 2):
          print(i)                # Prints 0, 2, 4, 6, 8

  - question: "What is a while loop and when do you use it?"
    answer: "A while loop repeats code as long as a condition is True. Use it when you don't know exactly how many times to repeat, but you know when to stop"
    code_example: |
      # Basic while loop
      count = 0
      while count < 5:
          print(f"Count is: {count}")
          count += 1              # Don't forget to update the condition!
      
      # User input loop
      user_input = ""
      while user_input != "quit":
          user_input = input("Enter 'quit' to exit: ")
          print(f"You entered: {user_input}")
      
      # Loop until condition met
      number = 1
      while number < 100:
          number = number * 2
          print(number)           # Prints 2, 4, 8, 16, 32, 64, 128
      
      # Infinite loop (be careful!)
      # while True:
      #     print("This runs forever!")

  - question: "What is the difference between for and while loops?"
    answer: "For loops are best for iterating over collections or counting, while loops are best for repeating until a condition changes. For loops have built-in iteration, while loops need manual condition updates"
    code_example: |
      # FOR LOOP - Best for known repetitions or collections
      
      # Counting (you know how many times)
      for i in range(10):
          print(i)
      
      # Processing items in a collection
      names = ["Alice", "Bob", "Charlie"]
      for name in names:
          print(name)
      
      # WHILE LOOP - Best for unknown repetitions
      
      # Loop until user does something
      password = ""
      while password != "secret":
          password = input("Enter password: ")
      
      # Loop until condition changes
      balance = 100
      while balance > 0:
          purchase = 15
          balance -= purchase
          print(f"Balance: ${balance}")
      
      # Both can often do the same thing, but for is usually cleaner:
      # Less preferred:
      i = 0
      while i < 5:
          print(i)
          i += 1
      
      # More preferred:
      for i in range(5):
          print(i)

  - question: "What is the range() function and how does it work with loops?"
    answer: "range() creates a sequence of numbers, commonly used with for loops. It can take 1, 2, or 3 arguments: range(stop), range(start, stop), or range(start, stop, step)"
    code_example: |
      # range(stop) - starts at 0, goes up to (but not including) stop
      for i in range(5):
          print(i)                # Prints: 0, 1, 2, 3, 4
      
      # range(start, stop) - starts at start, goes up to (but not including) stop
      for i in range(2, 7):
          print(i)                # Prints: 2, 3, 4, 5, 6
      
      # range(start, stop, step) - starts at start, increments by step
      for i in range(0, 10, 2):
          print(i)                # Prints: 0, 2, 4, 6, 8
      
      # Counting backwards
      for i in range(10, 0, -1):
          print(i)                # Prints: 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
      
      # Converting range to list (to see all values)
      numbers = list(range(5))    # [0, 1, 2, 3, 4]
      print(numbers)
      
      # Using range with len() to access indices
      fruits = ["apple", "banana", "orange"]
      for i in range(len(fruits)):
          print(f"Index {i}: {fruits[i]}")

  - question: "What are break and continue statements in loops?"
    answer: "break immediately exits the loop completely, while continue skips the rest of the current iteration and jumps to the next iteration"
    code_example: |
      # BREAK - exits the loop completely
      for i in range(10):
          if i == 5:
              break               # Stops the loop when i equals 5
          print(i)                # Prints: 0, 1, 2, 3, 4
      
      # CONTINUE - skips to next iteration
      for i in range(10):
          if i % 2 == 0:          # If i is even
              continue            # Skip the rest and go to next iteration
          print(i)                # Prints only odd numbers: 1, 3, 5, 7, 9
      
      # break in while loop
      count = 0
      while True:                 # Infinite loop
          count += 1
          if count > 5:
              break               # Exit when count exceeds 5
          print(count)
      
      # continue in while loop
      count = 0
      while count < 10:
          count += 1
          if count % 2 == 0:
              continue            # Skip even numbers
          print(count)            # Prints: 1, 3, 5, 7, 9
      
      # Practical example: input validation
      while True:
          age = input("Enter your age: ")
          if age.isdigit():
              age = int(age)
              if age >= 0:
                  break           # Valid age, exit loop
          print("Please enter a valid age")

  - question: "How do you loop through different data types in Python?"
    answer: "You can loop through strings (character by character), lists (item by item), dictionaries (keys, values, or both), and other iterable objects"
    code_example: |
      # Loop through STRING (character by character)
      word = "hello"
      for letter in word:
          print(letter)           # Prints: h, e, l, l, o
      
      # Loop through LIST (item by item)
      colors = ["red", "green", "blue"]
      for color in colors:
          print(color)
      
      # Loop through list with index
      for i, color in enumerate(colors):
          print(f"Index {i}: {color}")
      
      # Loop through DICTIONARY (keys only)
      person = {"name": "Alice", "age": 30, "city": "New York"}
      for key in person:
          print(key)              # Prints: name, age, city
      
      # Loop through dictionary values
      for value in person.values():
          print(value)            # Prints: Alice, 30, New York
      
      # Loop through dictionary key-value pairs
      for key, value in person.items():
          print(f"{key}: {value}")
      
      # Loop through TUPLE
      coordinates = (10, 20, 30)
      for coord in coordinates:
          print(coord)
      
      # Loop through RANGE
      for number in range(1, 6):
          print(number)           # Prints: 1, 2, 3, 4, 5

  - question: "What are nested loops and how do they work?"
    answer: "Nested loops are loops inside other loops. The inner loop completes all its iterations for each iteration of the outer loop"
    code_example: |
      # Basic nested loops
      for i in range(3):
          for j in range(2):
              print(f"Outer: {i}, Inner: {j}")
      
      # Output:
      # Outer: 0, Inner: 0
      # Outer: 0, Inner: 1
      # Outer: 1, Inner: 0
      # Outer: 1, Inner: 1
      # Outer: 2, Inner: 0
      # Outer: 2, Inner: 1
      
      # Practical example: multiplication table
      for i in range(1, 4):       # Outer loop: 1, 2, 3
          for j in range(1, 4):   # Inner loop: 1, 2, 3
              result = i * j
              print(f"{i} √ó {j} = {result}")
      
      # Nested loops with different data types
      subjects = ["Math", "Science"]
      grades = ["A", "B", "C"]
      
      for subject in subjects:
          for grade in grades:
              print(f"{subject}: {grade}")
      
      # Creating a 2D pattern
      for row in range(3):
          for col in range(4):
              print("*", end=" ")
          print()                 # New line after each row
      
      # Output:
      # * * * * 
      # * * * * 
      # * * * *

  - question: "What is an if statement and how does it work?"
    answer: "An if statement executes code only if a condition is True. It's the basic building block for making decisions in your program based on different conditions"
    code_example: |
      # Basic if statement
      age = 18
      if age >= 18:
          print("You are an adult")
      
      # If statement with variables
      temperature = 75
      if temperature > 70:
          print("It's warm outside")
      
      # If statement with user input
      name = input("Enter your name: ")
      if name == "Alice":
          print("Hello, Alice!")
      
      # Multiple conditions in one if
      score = 85
      if score >= 80 and score <= 100:
          print("Great job!")
      
      # If statement with function calls
      password = "secret123"
      if len(password) >= 8:
          print("Password is long enough")
      
      # Boolean variable in if statement
      is_logged_in = True
      if is_logged_in:
          print("Welcome back!")

  - question: "What is if/else and how does it work?"
    answer: "if/else allows you to execute one block of code if a condition is True, and a different block if it's False. This handles both possible outcomes of a condition"
    code_example: |
      # Basic if/else
      age = 16
      if age >= 18:
          print("You can vote")
      else:
          print("You cannot vote yet")
      
      # if/else with numbers
      number = 7
      if number % 2 == 0:
          print("Number is even")
      else:
          print("Number is odd")
      
      # if/else with strings
      weather = "sunny"
      if weather == "rainy":
          print("Take an umbrella")
      else:
          print("No umbrella needed")
      
      # if/else with return values
      def check_password(password):
          if len(password) >= 8:
              return "Strong password"
          else:
              return "Password too short"
      
      result = check_password("abc123")
      print(result)  # "Password too short"
      
      # if/else with variables
      balance = 50
      purchase = 75
      if balance >= purchase:
          balance -= purchase
          print(f"Purchase successful. New balance: ${balance}")
      else:
          print("Insufficient funds")

  - question: "What is if/elif/else and when do you use it?"
    answer: "elif (else if) allows you to check multiple conditions in sequence. Use it when you have more than two possible outcomes to handle"
    code_example: |
      # Basic if/elif/else
      score = 85
      if score >= 90:
          print("Grade: A")
      elif score >= 80:
          print("Grade: B")
      elif score >= 70:
          print("Grade: C")
      elif score >= 60:
          print("Grade: D")
      else:
          print("Grade: F")
      
      # Multiple elif statements
      day = "monday"
      if day == "saturday" or day == "sunday":
          print("It's weekend!")
      elif day == "monday":
          print("Start of work week")
      elif day == "friday":
          print("TGIF!")
      else:
          print("Regular work day")
      
      # elif with ranges
      temperature = 45
      if temperature < 32:
          print("Freezing")
      elif temperature < 50:
          print("Cold")
      elif temperature < 70:
          print("Cool")
      elif temperature < 85:
          print("Warm")
      else:
          print("Hot")
      
      # elif with user input
      choice = input("Enter 1, 2, or 3: ")
      if choice == "1":
          print("You chose option 1")
      elif choice == "2":
          print("You chose option 2")
      elif choice == "3":
          print("You chose option 3")
      else:
          print("Invalid choice")

  - question: "What are nested if statements?"
    answer: "Nested if statements are if statements inside other if statements. They allow you to check additional conditions only after the first condition is met"
    code_example: |
      # Basic nested if
      age = 20
      has_license = True
      
      if age >= 18:
          if has_license:
              print("You can drive")
          else:
              print("You need a license first")
      else:
          print("You're too young to drive")
      
      # Multiple levels of nesting
      weather = "sunny"
      temperature = 75
      
      if weather == "sunny":
          if temperature > 80:
              print("Perfect beach day!")
          elif temperature > 65:
              print("Nice day for a walk")
          else:
              print("Sunny but cold")
      else:
          if temperature > 70:
              print("Warm but not sunny")
          else:
              print("Cold and not sunny")
      
      # Nested with different data types
      user_type = "admin"
      logged_in = True
      
      if logged_in:
          if user_type == "admin":
              print("Access granted to admin panel")
          elif user_type == "user":
              print("Access granted to user panel")
          else:
              print("Unknown user type")
      else:
          print("Please log in first")
      
      # Alternative to nesting: using 'and'
      # Instead of nested if:
      if age >= 18:
          if has_license:
              print("Can drive")
      
      # You can often use 'and':
      if age >= 18 and has_license:
          print("Can drive")

  - question: "How do you use multiple conditions with and, or, and not?"
    answer: "'and' requires all conditions to be True, 'or' requires at least one condition to be True, and 'not' reverses the boolean value of a condition"
    code_example: |
      # AND operator - all conditions must be True
      age = 25
      has_license = True
      has_car = True
      
      if age >= 18 and has_license and has_car:
          print("Can drive own car")
      
      # OR operator - at least one condition must be True
      day = "saturday"
      if day == "saturday" or day == "sunday":
          print("It's weekend!")
      
      # NOT operator - reverses the boolean value
      is_raining = False
      if not is_raining:
          print("Good weather for outdoor activities")
      
      # Combining operators
      temperature = 75
      is_sunny = True
      is_weekend = True
      
      if (temperature > 70 and is_sunny) or is_weekend:
          print("Great day!")
      
      # More complex combinations
      score = 85
      extra_credit = 5
      is_honor_student = True
      
      if (score >= 90 or (score >= 80 and extra_credit > 0)) and is_honor_student:
          print("Qualifies for advanced program")
      
      # Using parentheses for clarity
      user_age = 16
      has_permit = True
      has_adult_supervisor = True
      
      if user_age >= 18 or (has_permit and has_adult_supervisor):
          print("Can drive legally")
      
      # NOT with other operators
      password = "abc123"
      if len(password) >= 8 and not password.isdigit():
          print("Good password")
      else:
          print("Password needs improvement")

  - question: "What are some common mistakes with if statements?"
    answer: "Common mistakes include using = instead of ==, forgetting colons, incorrect indentation, and not handling all possible cases in if/elif chains"
    code_example: |
      # MISTAKE 1: Using = instead of ==
      x = 5
      # if x = 5:           # ERROR! This is assignment, not comparison
      if x == 5:            # CORRECT! This compares x with 5
          print("x equals 5")
      
      # MISTAKE 2: Forgetting the colon
      # if x == 5           # ERROR! Missing colon
      if x == 5:            # CORRECT! Has colon
          print("x equals 5")
      
      # MISTAKE 3: Incorrect indentation
      # if x == 5:
      # print("x equals 5")  # ERROR! Not indented
      if x == 5:
          print("x equals 5")  # CORRECT! Properly indented
      
      # MISTAKE 4: Not handling all cases
      grade = 85
      if grade >= 90:
          print("A")
      elif grade >= 80:
          print("B")
      # What if grade is 75? Nothing happens!
      
      # BETTER: Always include else for unexpected cases
      if grade >= 90:
          print("A")
      elif grade >= 80:
          print("B")
      elif grade >= 70:
          print("C")
      else:
          print("Below C")
      
      # MISTAKE 5: Confusing and/or logic
      age = 25
      income = 30000
      
      # Wrong logic: This means age >= 18 AND income >= 25000
      # if age >= 18 and income >= 25000:
      
      # If you want either condition to qualify:
      if age >= 18 or income >= 25000:
          print("Qualifies")
      
      # MISTAKE 6: Not using parentheses for complex conditions
      # Hard to read:
      if age >= 18 and income >= 25000 or age >= 21 and income >= 20000:
          print("Qualifies")
      
      # Better with parentheses:
      if (age >= 18 and income >= 25000) or (age >= 21 and income >= 20000):
          print("Qualifies")

  - question: "What is a list in Python and how do you create one?"
    answer: "A list is an ordered collection of items that can hold different data types. Create lists using square brackets [] with items separated by commas"
    code_example: |
      # Empty list
      empty_list = []
      
      # List with numbers
      numbers = [1, 2, 3, 4, 5]
      
      # List with strings
      fruits = ["apple", "banana", "orange"]
      
      # List with mixed data types
      mixed = [1, "hello", 3.14, True]
      
      # List with duplicate values (allowed)
      scores = [85, 92, 78, 85, 90]
      
      # Creating list from range
      range_list = list(range(5))        # [0, 1, 2, 3, 4]
      
      # Creating list with repeated values
      zeros = [0] * 5                    # [0, 0, 0, 0, 0]
      
      # List inside another list (nested)
      nested = [[1, 2], [3, 4], [5, 6]]
      
      # Converting string to list
      letters = list("hello")            # ['h', 'e', 'l', 'l', 'o']
      
      # List from user input
      user_input = input("Enter names: ").split()  # Splits by spaces
      print(user_input)

  - question: "How do you access items in a list using indexing?"
    answer: "Use square brackets with the index number. Python uses 0-based indexing, so the first item is at index 0. Negative indices count from the end"
    code_example: |
      fruits = ["apple", "banana", "orange", "grape", "kiwi"]
      
      # Positive indexing (from the beginning)
      first_fruit = fruits[0]            # "apple"
      second_fruit = fruits[1]           # "banana"
      third_fruit = fruits[2]            # "orange"
      
      # Negative indexing (from the end)
      last_fruit = fruits[-1]            # "kiwi"
      second_last = fruits[-2]           # "grape"
      
      # Index positions explained:
      # Index:    0        1         2        3       4
      # Values: "apple", "banana", "orange", "grape", "kiwi"
      # Negative: -5       -4        -3       -2      -1
      
      # Using variables as indices
      index = 2
      selected_fruit = fruits[index]     # "orange"
      
      # Common error: index out of range
      # print(fruits[10])                # ERROR! Index 10 doesn't exist
      
      # Safe way to check if index exists
      if 0 <= index < len(fruits):
          print(fruits[index])
      else:
          print("Index out of range")

  - question: "How do you add items to a list?"
    answer: "Use append() to add one item to the end, insert() to add at a specific position, extend() to add multiple items, or + operator to combine lists"
    code_example: |
      fruits = ["apple", "banana"]
      
      # append() - adds one item to the end
      fruits.append("orange")
      print(fruits)                      # ["apple", "banana", "orange"]
      
      # insert() - adds item at specific position
      fruits.insert(1, "grape")
      print(fruits)                      # ["apple", "grape", "banana", "orange"]
      
      # extend() - adds multiple items to the end
      fruits.extend(["kiwi", "mango"])
      print(fruits)                      # ["apple", "grape", "banana", "orange", "kiwi", "mango"]
      
      # + operator - combines lists (creates new list)
      more_fruits = ["pear", "peach"]
      all_fruits = fruits + more_fruits
      print(all_fruits)
      
      # += operator - adds to existing list
      fruits += ["strawberry"]
      print(fruits)
      
      # Adding different data types
      mixed_list = [1, 2, 3]
      mixed_list.append("hello")
      mixed_list.append(True)
      print(mixed_list)                  # [1, 2, 3, "hello", True]
      
      # append() vs extend() difference
      list1 = [1, 2, 3]
      list1.append([4, 5])               # Adds entire list as one item
      print(list1)                       # [1, 2, 3, [4, 5]]
      
      list2 = [1, 2, 3]
      list2.extend([4, 5])               # Adds each item separately
      print(list2)                       # [1, 2, 3, 4, 5]

  - question: "How do you remove items from a list?"
    answer: "Use remove() to remove by value, pop() to remove by index, del to delete by index, or clear() to remove all items"
    code_example: |
      fruits = ["apple", "banana", "orange", "banana", "grape"]
      
      # remove() - removes first occurrence of value
      fruits.remove("banana")
      print(fruits)                      # ["apple", "orange", "banana", "grape"]
      
      # pop() - removes and returns item at index (default: last item)
      last_fruit = fruits.pop()
      print(last_fruit)                  # "grape"
      print(fruits)                      # ["apple", "orange", "banana"]
      
      # pop() with specific index
      first_fruit = fruits.pop(0)
      print(first_fruit)                 # "apple"
      print(fruits)                      # ["orange", "banana"]
      
      # del statement - removes item at index
      del fruits[0]
      print(fruits)                      # ["banana"]
      
      # clear() - removes all items
      fruits.clear()
      print(fruits)                      # []
      
      # Removing multiple items using slicing
      numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
      del numbers[2:5]                   # Removes items at indices 2, 3, 4
      print(numbers)                     # [1, 2, 6, 7, 8, 9, 10]
      
      # Safe removal with error handling
      my_list = [1, 2, 3]
      try:
          my_list.remove(4)              # Will raise ValueError
      except ValueError:
          print("Item not found in list")
      
      # Remove all occurrences of a value
      items = [1, 2, 3, 2, 4, 2, 5]
      while 2 in items:
          items.remove(2)
      print(items)                       # [1, 3, 4, 5]

  - question: "What are list inspection methods in Python?"
    answer: "List inspection methods help you examine and search within lists. Use len() for length, count() for occurrences, index() for position, and 'in' operator for membership testing"
    code_example: |
      fruits = ["apple", "banana", "orange", "banana", "grape"]
      numbers = [3, 1, 4, 1, 5, 9, 2, 6]
      
      # len() - get number of items
      print(len(fruits))                 # 5
      print(len(numbers))                # 8
      
      # count() - count occurrences of value
      banana_count = fruits.count("banana")
      print(banana_count)                # 2 (banana appears twice)
      
      one_count = numbers.count(1)
      print(one_count)                   # 2 (1 appears twice)
      
      # index() - find first occurrence of value
      orange_index = fruits.index("orange")
      print(orange_index)                # 2 (orange is at index 2)
      
      # Safe index finding with error handling
      try:
          kiwi_index = fruits.index("kiwi")
      except ValueError:
          print("Kiwi not found in list")
      
      # in operator - check if item exists (returns True/False)
      print("apple" in fruits)           # True
      print("kiwi" in fruits)            # False
      print(5 in numbers)                # True
      
      # not in operator - check if item doesn't exist
      if "strawberry" not in fruits:
          print("No strawberry in the list")
      
      # Combining inspection methods
      def find_all_indices(lst, item):
          indices = []
          start = 0
          while True:
              try:
                  index = lst.index(item, start)
                  indices.append(index)
                  start = index + 1
              except ValueError:
                  break
          return indices
      
      # Find all positions of "banana"
      banana_positions = find_all_indices(fruits, "banana")
      print(banana_positions)            # [1, 3]

  - question: "What are list sorting and ordering methods in Python?"
    answer: "Use sort() to modify a list in place, sorted() to create a new sorted list, and reverse() to reverse the order. Both sort methods can be customized with reverse parameter"
    code_example: |
      numbers = [3, 1, 4, 1, 5, 9, 2, 6]
      fruits = ["banana", "apple", "cherry", "date"]
      
      # sort() - modifies the original list
      numbers.sort()
      print(numbers)                     # [1, 1, 2, 3, 4, 5, 6, 9]
      
      # sort() with reverse (descending order)
      numbers.sort(reverse=True)
      print(numbers)                     # [9, 6, 5, 4, 3, 2, 1, 1]
      
      # sorted() - creates new sorted list, original unchanged
      original = [3, 1, 4, 1, 5]
      sorted_list = sorted(original)
      print(original)                    # [3, 1, 4, 1, 5] (unchanged)
      print(sorted_list)                 # [1, 1, 3, 4, 5]
      
      # Sorting strings (alphabetical order)
      fruits.sort()
      print(fruits)                      # ['apple', 'banana', 'cherry', 'date']
      
      # reverse() - reverses the current order
      fruits.reverse()
      print(fruits)                      # ['date', 'cherry', 'banana', 'apple']
      
      # Sorting by custom criteria (advanced)
      words = ["python", "java", "c", "javascript"]
      
      # Sort by length
      words.sort(key=len)
      print(words)                       # ['c', 'java', 'python', 'javascript']
      
      # Sort by length, longest first
      words.sort(key=len, reverse=True)
      print(words)                       # ['javascript', 'python', 'java', 'c']
      
      # Case-insensitive sorting
      names = ["Alice", "bob", "Charlie", "diana"]
      names.sort(key=str.lower)
      print(names)                       # ['Alice', 'bob', 'Charlie', 'diana']

  - question: "What are list aggregation functions in Python?"
    answer: "Aggregation functions compute single values from lists. Use min() for smallest value, max() for largest value, and sum() for total of numeric lists"
    code_example: |
      numbers = [3, 1, 4, 1, 5, 9, 2, 6]
      prices = [19.99, 5.50, 12.00, 8.25]
      words = ["python", "java", "c", "javascript"]
      
      # min() - find smallest value
      print(min(numbers))                # 1
      print(min(prices))                 # 5.5
      print(min(words))                  # 'c' (alphabetically first)
      
      # max() - find largest value
      print(max(numbers))                # 9
      print(max(prices))                 # 19.99
      print(max(words))                  # 'python' (alphabetically last)
      
      # sum() - add all numeric values
      print(sum(numbers))                # 31
      print(sum(prices))                 # 45.74
      
      # Average calculation
      average = sum(numbers) / len(numbers)
      print(f"Average: {average}")       # Average: 3.875
      
      # Min/max with custom key
      shortest_word = min(words, key=len)
      longest_word = max(words, key=len)
      print(f"Shortest: {shortest_word}") # Shortest: c
      print(f"Longest: {longest_word}")   # Longest: javascript
      
      # Working with empty lists (be careful!)
      empty_list = []
      try:
          print(min(empty_list))
      except ValueError:
          print("Cannot find min of empty list")
      
      # Safe aggregation with default values
      def safe_min(lst, default=None):
          return min(lst) if lst else default
      
      def safe_max(lst, default=None):
          return max(lst) if lst else default
      
      def safe_sum(lst):
          return sum(lst) if lst else 0
      
      print(safe_min(empty_list, 0))     # 0
      print(safe_max(empty_list, 0))     # 0
      print(safe_sum(empty_list))        # 0
      
      # Statistical operations
      grades = [85, 92, 78, 96, 88, 91]
      print(f"Highest grade: {max(grades)}")
      print(f"Lowest grade: {min(grades)}")
      print(f"Total points: {sum(grades)}")
      print(f"Average grade: {sum(grades) / len(grades):.1f}")

  - question: "How do you modify existing items in a list?"
    answer: "Use indexing to assign new values to specific positions, or use slicing to replace multiple items at once"
    code_example: |
      fruits = ["apple", "banana", "orange", "grape"]
      
      # Modify single item by index
      fruits[1] = "blueberry"
      print(fruits)                      # ["apple", "blueberry", "orange", "grape"]
      
      # Modify multiple items using slicing
      fruits[1:3] = ["kiwi", "mango"]
      print(fruits)                      # ["apple", "kiwi", "mango", "grape"]
      
      # Replace multiple items with different number of items
      fruits[1:3] = ["strawberry"]       # Replaces 2 items with 1
      print(fruits)                      # ["apple", "strawberry", "grape"]
      
      # Modify using negative indexing
      fruits[-1] = "pear"
      print(fruits)                      # ["apple", "strawberry", "pear"]
      
      # Modify all items using a loop
      numbers = [1, 2, 3, 4, 5]
      for i in range(len(numbers)):
          numbers[i] = numbers[i] * 2
      print(numbers)                     # [2, 4, 6, 8, 10]
      
      # Modify using enumerate
      words = ["hello", "world", "python"]
      for i, word in enumerate(words):
          words[i] = word.upper()
      print(words)                       # ["HELLO", "WORLD", "PYTHON"]
      
      # Creating new list with modifications
      original = [1, 2, 3, 4, 5]
      doubled = []
      for x in original:
          doubled.append(x * 2)
      print(doubled)                     # [2, 4, 6, 8, 10]
      
      # Conditional modification
      grades = [85, 92, 78, 96, 88]
      for i in range(len(grades)):
          if grades[i] < 80:
              grades[i] = 80             # Curve up low grades
      print(grades)                      # [85, 92, 80, 96, 88]

  - question: "What is a dictionary in Python and how do you create one?"
    answer: "A dictionary is a collection of key-value pairs where each key is unique and maps to a value. Create dictionaries using curly braces {} with key:value pairs separated by commas"
    code_example: |
      # Empty dictionary
      empty_dict = {}
      
      # Dictionary with string keys
      person = {"name": "Alice", "age": 30, "city": "New York"}
      
      # Dictionary with mixed key types
      mixed_keys = {1: "one", "two": 2, 3.0: "three"}
      
      # Dictionary with different value types
      student = {
          "name": "Bob",
          "age": 22,
          "grades": [85, 90, 78],
          "is_enrolled": True
      }
      
      # Creating dictionary from lists
      keys = ["apple", "banana", "orange"]
      values = [1.50, 0.75, 2.00]
      prices = dict(zip(keys, values))   # {"apple": 1.50, "banana": 0.75, "orange": 2.00}
      
      # Dictionary constructor
      colors = dict(red="#FF0000", green="#00FF00", blue="#0000FF")
      
      # Nested dictionaries
      employees = {
          "employee1": {"name": "Alice", "department": "IT"},
          "employee2": {"name": "Bob", "department": "Sales"}
      }
      
      # Dictionary from pairs
      pairs = [("a", 1), ("b", 2), ("c", 3)]
      letter_dict = dict(pairs)          # {"a": 1, "b": 2, "c": 3}

  - question: "How do you access and modify values in a dictionary?"
    answer: "Use square brackets [key] or get() method to access values. Use square brackets to modify existing values or add new key-value pairs"
    code_example: |
      person = {"name": "Alice", "age": 30, "city": "New York"}
      
      # Accessing values with square brackets
      name = person["name"]              # "Alice"
      age = person["age"]                # 30
      
      # Accessing with get() method (safer)
      name = person.get("name")          # "Alice"
      country = person.get("country")    # None (key doesn't exist)
      
      # get() with default value
      country = person.get("country", "USA")  # "USA" (default)
      
      # Modifying existing values
      person["age"] = 31
      person["city"] = "Boston"
      print(person)                      # {"name": "Alice", "age": 31, "city": "Boston"}
      
      # Adding new key-value pairs
      person["email"] = "alice@example.com"
      person["phone"] = "555-1234"
      print(person)
      
      # Accessing nested dictionaries
      employee = {
          "name": "Bob",
          "contact": {
              "email": "bob@company.com",
              "phone": "555-5678"
          }
      }
      
      email = employee["contact"]["email"]  # "bob@company.com"
      
      # Safe access to nested values
      email = employee.get("contact", {}).get("email", "No email")
      
      # Error handling for missing keys
      try:
          salary = person["salary"]
      except KeyError:
          print("Salary not found")

  - question: "What are common dictionary methods and operations?"
    answer: "Common methods include keys(), values(), items(), pop(), update(), clear(), and operators like 'in' to check for key existence"
    code_example: |
      person = {"name": "Alice", "age": 30, "city": "New York", "email": "alice@example.com"}
      
      # Get all keys
      keys = person.keys()
      print(list(keys))                  # ["name", "age", "city", "email"]
      
      # Get all values
      values = person.values()
      print(list(values))                # ["Alice", 30, "New York", "alice@example.com"]
      
      # Get all key-value pairs
      items = person.items()
      print(list(items))                 # [("name", "Alice"), ("age", 30), ...]
      
      # Check if key exists
      if "name" in person:
          print("Name is in the dictionary")
      
      # Check if value exists
      if "Alice" in person.values():
          print("Alice is a value in the dictionary")
      
      # Get length (number of key-value pairs)
      print(len(person))                 # 4
      
      # pop() - remove and return value
      email = person.pop("email")
      print(email)                       # "alice@example.com"
      print(person)                      # email key is removed
      
      # pop() with default
      phone = person.pop("phone", "No phone")  # "No phone"
      
      # update() - merge with another dictionary
      additional_info = {"phone": "555-1234", "age": 31}
      person.update(additional_info)
      print(person)
      
      # clear() - remove all items
      temp_dict = {"a": 1, "b": 2}
      temp_dict.clear()
      print(temp_dict)                   # {}
      
      # copy() - create a shallow copy
      person_copy = person.copy()

  - question: "How do you loop through dictionaries?"
    answer: "You can loop through keys (default), values using .values(), or key-value pairs using .items(). Use different loop patterns based on what you need to access"
    code_example: |
      grades = {"Alice": 85, "Bob": 92, "Charlie": 78, "Diana": 96}
      
      # Loop through keys (default behavior)
      for name in grades:
          print(f"{name}: {grades[name]}")
      
      # Loop through keys explicitly
      for name in grades.keys():
          print(f"Student: {name}")
      
      # Loop through values
      for grade in grades.values():
          print(f"Grade: {grade}")
      
      # Loop through key-value pairs (most common)
      for name, grade in grades.items():
          print(f"{name} scored {grade}")
      
      # Loop with conditions
      for name, grade in grades.items():
          if grade >= 90:
              print(f"{name} got an A!")
      
      # Calculate average using loop
      total = 0
      for grade in grades.values():
          total += grade
      average = total / len(grades)
      print(f"Average grade: {average}")
      
      # Find highest grade
      highest_grade = 0
      best_student = ""
      for name, grade in grades.items():
          if grade > highest_grade:
              highest_grade = grade
              best_student = name
      print(f"Best student: {best_student} with {highest_grade}")
      
      # Loop through nested dictionary
      employees = {
          "emp1": {"name": "Alice", "department": "IT"},
          "emp2": {"name": "Bob", "department": "Sales"}
      }
      
      for emp_id, info in employees.items():
          print(f"{emp_id}: {info['name']} works in {info['department']}")

  - question: "How do you add, remove, and modify dictionary items?"
    answer: "Add items by assigning to new keys, remove with del, pop(), or popitem(), and modify by reassigning values to existing keys"
    code_example: |
      inventory = {"apples": 50, "bananas": 30, "oranges": 25}
      
      # Adding new items
      inventory["grapes"] = 40
      inventory["kiwis"] = 15
      print(inventory)
      
      # Modifying existing items
      inventory["apples"] = 60          # Update apple count
      inventory["bananas"] += 20        # Add to banana count
      print(inventory)
      
      # Removing items with del
      del inventory["kiwis"]
      print(inventory)
      
      # Removing items with pop() (returns value)
      orange_count = inventory.pop("oranges")
      print(f"Removed {orange_count} oranges")
      print(inventory)
      
      # pop() with default value
      mango_count = inventory.pop("mangoes", 0)  # 0 if key doesn't exist
      print(f"Mango count: {mango_count}")
      
      # popitem() - removes and returns last item (Python 3.7+)
      last_item = inventory.popitem()
      print(f"Removed item: {last_item}")
      
      # Conditional adding/updating
      product = "strawberries"
      if product in inventory:
          inventory[product] += 10
      else:
          inventory[product] = 10
      
      # Using setdefault() for conditional adding
      inventory.setdefault("blueberries", 0)  # Adds key with value 0 if not exists
      inventory.setdefault("apples", 0)       # Doesn't change existing value
      
      # Bulk updates with update()
      new_stock = {"pears": 35, "apples": 70, "cherries": 20}
      inventory.update(new_stock)
      print(inventory)
      
      # Remove all items
      inventory.clear()
      print(inventory)                   # {}

  - question: "When should you use lists vs dictionaries?"
    answer: "Use lists for ordered collections accessed by position/index. Use dictionaries for key-value relationships where you need fast lookups by unique identifiers"
    code_example: |
      # Use LIST when:
      # - Order matters
      # - You access items by position
      # - You need to maintain sequence
      # - You want to allow duplicates
      
      # Examples where lists are better:
      shopping_list = ["milk", "bread", "eggs", "milk"]  # Order matters, duplicates OK
      grades = [85, 90, 78, 92]                          # Position indicates test number
      steps = ["Wash hands", "Prep ingredients", "Cook"] # Sequential steps
      
      # Use DICTIONARY when:
      # - You need fast lookups by key
      # - You want to associate values with identifiers
      # - Order doesn't matter (or only insertion order)
      # - Keys should be unique
      
      # Examples where dictionaries are better:
      phone_book = {"Alice": "555-1234", "Bob": "555-5678"}  # Look up by name
      student_grades = {"Alice": 85, "Bob": 90, "Charlie": 78}  # Associate grades with names
      config = {"debug": True, "port": 8080, "host": "localhost"}  # Configuration settings
      
      # COMPARISON EXAMPLE:
      # Bad: Using list for student data
      students = [
          ["Alice", 85, "alice@email.com"],
          ["Bob", 90, "bob@email.com"]
      ]
      # To find Alice's grade: need to search through all students
      for student in students:
          if student[0] == "Alice":
              print(f"Alice's grade: {student[1]}")
      
      # Better: Using dictionary
      students = {
          "Alice": {"grade": 85, "email": "alice@email.com"},
          "Bob": {"grade": 90, "email": "bob@email.com"}
      }
      # Direct lookup - much faster!
      print(f"Alice's grade: {students['Alice']['grade']}")
      
      # HYBRID APPROACH:
      # Sometimes you need both - list of dictionaries
      students = [
          {"name": "Alice", "grade": 85, "email": "alice@email.com"},
          {"name": "Bob", "grade": 90, "email": "bob@email.com"}
      ]
      # Maintains order AND allows structured data

  - question: "What does 'indentation' mean in programming?"
    answer: "Indentation refers to the spaces or tabs at the beginning of code lines. In Python, indentation is crucial as it defines code blocks and structure"
    code_example: |
      # Python uses indentation to define code blocks
      
      # Correct indentation
      if True:
          print("This is indented")        # 4 spaces
          print("This is also indented")   # 4 spaces
      
      # Nested indentation
      for i in range(3):
          print(f"Outer loop: {i}")        # 4 spaces
          for j in range(2):
              print(f"  Inner loop: {j}")  # 8 spaces
      
      # Function indentation
      def my_function():
          x = 5                           # 4 spaces
          if x > 0:
              print("Positive")           # 8 spaces
          else:
              print("Not positive")       # 8 spaces
      
      # IndentationError example
      # if True:
      # print("This will cause an error")  # ERROR: not indented
      
      # Consistent indentation is important
      if True:
          print("First line")             # 4 spaces
          print("Second line")            # 4 spaces (consistent)

  - question: "What is 'syntax' in programming?"
    answer: "Syntax refers to the set of rules that define how to write valid code in a programming language. It's like grammar rules for code"
    code_example: |
      # Python syntax examples:
      
      # Variable assignment syntax
      name = "Alice"                      # Correct syntax
      # name = Alice                      # ERROR: missing quotes
      
      # Function definition syntax
      def greet(name):                    # Correct: def, name, parentheses, colon
          return f"Hello, {name}"
      
      # def greet name:                   # ERROR: missing parentheses
      # def greet(name)                   # ERROR: missing colon
      
      # If statement syntax
      if x > 5:                          # Correct: if, condition, colon
          print("Greater than 5")
      
      # if x > 5                         # ERROR: missing colon
      # if (x > 5):                      # Valid but not typical Python style
      
      # List syntax
      numbers = [1, 2, 3, 4, 5]          # Correct: square brackets, commas
      # numbers = (1, 2, 3, 4, 5)        # This is a tuple, not a list
      
      # Dictionary syntax
      person = {"name": "Alice", "age": 30}  # Correct: curly braces, colons
      # person = {name: "Alice", age: 30}     # ERROR: keys need quotes

  - question: "What is a tuple in Python and how do you create one?"
    answer: "A tuple is an immutable ordered collection of items. Create tuples using parentheses () with items separated by commas"
    code_example: |
      # Basic tuple creation
      coordinates = (10, 20)
      colors = ("red", "green", "blue")
      
      # Single item tuple (comma required)
      single_item = (42,)           # Tuple with one item
      not_tuple = (42)              # This is just parentheses around an int
      
      # Tuple without parentheses (valid but less clear)
      point = 5, 10                 # Creates tuple (5, 10)
      
      # Empty tuple
      empty = ()
      
      # Mixed data types
      mixed = ("Alice", 25, True, 3.14)
      
      # Converting to tuple
      list_to_tuple = tuple([1, 2, 3])  # (1, 2, 3)
      string_to_tuple = tuple("hello")   # ('h', 'e', 'l', 'l', 'o')

  - question: "How do you access and unpack tuples?"
    answer: "Access tuple items using indexing like lists. Unpack tuples by assigning to multiple variables simultaneously"
    code_example: |
      coordinates = (10, 20, 30)
      
      # Access by index (like lists)
      x = coordinates[0]            # 10
      y = coordinates[1]            # 20
      z = coordinates[-1]           # 30 (last item)
      
      # Tuple unpacking (multiple assignment)
      x, y, z = coordinates         # x=10, y=20, z=30
      
      # Partial unpacking with underscore
      x, y, _ = coordinates         # Ignore the third value
      
      # Swapping variables using tuples
      a = 5
      b = 10
      a, b = b, a                   # Now a=10, b=5
      
      # Function returning multiple values
      def get_name_age():
          return "Alice", 25        # Returns a tuple
      
      name, age = get_name_age()    # Unpack the returned tuple
      
      # Enumerate returns tuples
      fruits = ["apple", "banana", "orange"]
      for index, fruit in enumerate(fruits):
          print(f"{index}: {fruit}")

  - question: "What are string case conversion methods in Python?"
    answer: "String case methods change the capitalization of text. Use upper() for all uppercase, lower() for all lowercase, title() for title case, and capitalize() for sentence case"
    code_example: |
      text = "hello world python"
      
      # Convert to uppercase
      print(text.upper())           # "HELLO WORLD PYTHON"
      
      # Convert to lowercase
      mixed_case = "HeLLo WoRLd"
      print(mixed_case.lower())     # "hello world"
      
      # Title case (first letter of each word capitalized)
      print(text.title())           # "Hello World Python"
      
      # Capitalize (only first letter of string)
      print(text.capitalize())      # "Hello world python"
      
      # Case checking methods
      print("HELLO".isupper())      # True
      print("hello".islower())      # True
      print("Hello World".istitle()) # True
      
      # Practical usage
      name = "alice smith"
      proper_name = name.title()    # "Alice Smith"
      
      # User input normalization
      user_input = "YES"
      if user_input.lower() == "yes":
          print("User confirmed")

  - question: "What are string whitespace methods in Python?"
    answer: "Whitespace methods remove unwanted spaces, tabs, and newlines. Use strip() to remove from both ends, lstrip() from the left, and rstrip() from the right"
    code_example: |
      text = "  Hello, World!  \n"
      
      # Remove whitespace from both ends
      print(repr(text.strip()))     # "'Hello, World!'"
      
      # Remove whitespace from left side only
      print(repr(text.lstrip()))    # "'Hello, World!  \n'"
      
      # Remove whitespace from right side only
      print(repr(text.rstrip()))    # "'  Hello, World!'"
      
      # Remove specific characters
      messy_text = "...Hello World!!!"
      print(messy_text.strip(".!"))  # "Hello World"
      
      # Common use case: cleaning user input
      user_input = "  alice@email.com  "
      clean_email = user_input.strip()  # "alice@email.com"
      
      # Multi-line text cleaning
      lines = ["  line 1  ", "  line 2  ", "  line 3  "]
      clean_lines = [line.strip() for line in lines]
      print(clean_lines)             # ["line 1", "line 2", "line 3"]
      
      # Check for whitespace
      print("   ".isspace())         # True
      print("hello".isspace())       # False

  - question: "What are string search and replace methods in Python?"
    answer: "Search methods help find text within strings. Use find() to get index position, replace() to substitute text, startswith() and endswith() to check beginnings and endings"
    code_example: |
      text = "Python is awesome. Python is powerful."
      
      # Find index of substring
      index = text.find("awesome")
      print(index)                   # 10 (index where found)
      print(text.find("Java"))       # -1 (not found)
      
      # Check if string starts/ends with specific text
      print(text.startswith("Python"))  # True
      print(text.endswith("powerful.")) # True
      print(text.startswith("Java"))     # False
      
      # Replace text (returns new string)
      new_text = text.replace("Python", "JavaScript")
      print(new_text)                # "JavaScript is awesome. JavaScript is powerful."
      
      # Replace only first occurrence
      partial_replace = text.replace("Python", "JS", 1)
      print(partial_replace)         # "JS is awesome. Python is powerful."
      
      # Case-insensitive searching
      text_lower = text.lower()
      if "python" in text_lower:
          print("Found Python (case-insensitive)")
      
      # Split strings
      words = "apple,banana,orange".split(",")
      print(words)                   # ['apple', 'banana', 'orange']
      
      sentence = "Hello world Python"
      word_list = sentence.split()   # Splits on whitespace
      print(word_list)               # ['Hello', 'world', 'Python']

  - question: "What are string content checking methods in Python?"
    answer: "Content checking methods test what type of characters a string contains. Use isdigit() for numbers, isalpha() for letters, isalnum() for letters and numbers"
    code_example: |
      # Check if string contains only digits
      print("123".isdigit())         # True
      print("12.3".isdigit())        # False (decimal point)
      print("abc".isdigit())         # False
      
      # Check if string contains only letters
      print("abc".isalpha())         # True
      print("Hello".isalpha())       # True
      print("abc123".isalpha())      # False (contains numbers)
      print("hello world".isalpha()) # False (contains space)
      
      # Check if string contains only letters and numbers
      print("abc123".isalnum())      # True
      print("Hello123".isalnum())    # True
      print("abc 123".isalnum())     # False (contains space)
      
      # Other useful checking methods
      print("HELLO".isupper())       # True
      print("hello".islower())       # True
      print("Hello World".istitle()) # True
      print("   ".isspace())         # True (only whitespace)
      
      # Practical usage: input validation
      user_age = input("Enter your age: ")
      if user_age.isdigit():
          age = int(user_age)
          print(f"You are {age} years old")
      else:
          print("Please enter a valid number")
      
      # Validate username (letters and numbers only)
      username = "user123"
      if username.isalnum():
          print("Valid username")
      else:
          print("Username can only contain letters and numbers")

  - question: "What is string formatting in Python?"
    answer: "String formatting allows you to insert variables into strings. Use f-strings (preferred), .format() method, or % formatting"
    code_example: |
      name = "Alice"
      age = 25
      score = 87.5
      
      # f-strings (Python 3.6+, preferred method)
      message = f"Hello, {name}! You are {age} years old."
      formatted = f"Score: {score:.1f}%"        # One decimal place
      expression = f"Next year: {age + 1}"      # Can include expressions
      
      # .format() method
      message = "Hello, {}! You are {} years old.".format(name, age)
      message = "Hello, {name}! You are {age} years old.".format(name=name, age=age)
      
      # % formatting (older style)
      message = "Hello, %s! You are %d years old." % (name, age)
      
      # f-string formatting options
      pi = 3.14159
      print(f"Pi: {pi:.2f}")        # "Pi: 3.14"
      print(f"Pi: {pi:>10.2f}")     # "Pi:       3.14" (right-aligned)
      print(f"Number: {42:04d}")    # "Number: 0042" (zero-padded)
      
      # Multi-line f-strings
      report = f"""
      Student: {name}
      Age: {age}
      Score: {score:.1f}%
      """

  - question: "What are type conversion and checking functions in Python?"
    answer: "Type functions help you work with data types. Use type() to check types, isinstance() for type validation, and str(), int(), float(), bool() to convert between types"
    code_example: |
      # Checking types
      print(type(42))               # <class 'int'>
      print(type("hello"))          # <class 'str'>
      print(type([1, 2, 3]))        # <class 'list'>
      print(type(3.14))             # <class 'float'>
      
      # Type validation with isinstance()
      value = 42
      print(isinstance(value, int))     # True
      print(isinstance(value, str))     # False
      print(isinstance(value, (int, float)))  # True (checks multiple types)
      
      # Converting to string
      number = 42
      pi = 3.14159
      boolean = True
      print(str(number))            # "42"
      print(str(pi))                # "3.14159"
      print(str(boolean))           # "True"
      
      # Converting to integer
      print(int("42"))              # 42
      print(int(3.9))               # 3 (truncates decimal)
      print(int(True))              # 1
      print(int(False))             # 0
      
      # Converting to float
      print(float("3.14"))          # 3.14
      print(float(42))              # 42.0
      print(float("42"))            # 42.0
      
      # Converting to boolean
      print(bool(1))                # True
      print(bool(0))                # False
      print(bool("hello"))          # True
      print(bool(""))               # False
      print(bool([1, 2, 3]))        # True
      print(bool([]))               # False
      
      # Safe type conversion with error handling
      def safe_int(value, default=0):
          try:
              return int(value)
          except (ValueError, TypeError):
              return default
      
      print(safe_int("123"))        # 123
      print(safe_int("abc"))        # 0 (default)

  - question: "What are collection functions in Python?"
    answer: "Collection functions work with groups of data. Use len() for size, min() for smallest value, max() for largest value, and sum() for totals of numeric collections"
    code_example: |
      numbers = [1, 2, 3, 4, 5]
      words = ["python", "java", "javascript", "c"]
      mixed = [10, 5, 8, 12, 3]
      
      # len() - get length/size of collections
      print(len(numbers))           # 5
      print(len(words))             # 4
      print(len("hello"))           # 5 (works with strings too)
      print(len({"a": 1, "b": 2}))  # 2 (works with dictionaries)
      
      # min() - find smallest value
      print(min(numbers))           # 1
      print(min(words))             # "c" (alphabetically first)
      print(min("hello"))           # "e" (smallest character)
      
      # max() - find largest value
      print(max(numbers))           # 5
      print(max(words))             # "python" (alphabetically last)
      print(max("hello"))           # "o" (largest character)
      
      # sum() - add all numeric values
      print(sum(numbers))           # 15
      print(sum(mixed))             # 38
      
      # sum() with start value
      print(sum(numbers, 10))       # 25 (15 + 10)
      
      # Working with nested collections
      matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
      print(len(matrix))            # 3 (number of rows)
      print(len(matrix[0]))         # 3 (number of columns in first row)
      
      # Flattening and summing nested list
      all_numbers = []
      for row in matrix:
          all_numbers.extend(row)
      print(sum(all_numbers))       # 45
      
      # Using with custom key functions
      students = ["Alice", "Bob", "Alexander", "Jo"]
      shortest_name = min(students, key=len)
      longest_name = max(students, key=len)
      print(f"Shortest: {shortest_name}")  # "Jo"
      print(f"Longest: {longest_name}")    # "Alexander"

  - question: "What are iteration functions in Python?"
    answer: "Iteration functions help you loop through data differently. Use enumerate() to get index and value pairs, zip() to combine multiple sequences, and range() for number sequences"
    code_example: |
      # enumerate() - get index and value pairs
      fruits = ["apple", "banana", "orange"]
      for index, fruit in enumerate(fruits):
          print(f"Index {index}: {fruit}")
      # Output: Index 0: apple, Index 1: banana, Index 2: orange
      
      # enumerate() with custom start
      for index, fruit in enumerate(fruits, start=1):
          print(f"Item {index}: {fruit}")
      # Output: Item 1: apple, Item 2: banana, Item 3: orange
      
      # zip() - combine multiple sequences
      names = ["Alice", "Bob", "Charlie"]
      ages = [25, 30, 35]
      cities = ["New York", "London", "Tokyo"]
      
      for name, age in zip(names, ages):
          print(f"{name} is {age} years old")
      
      # zip() with three lists
      for name, age, city in zip(names, ages, cities):
          print(f"{name}, {age}, lives in {city}")
      
      # zip() stops at shortest list
      short_list = [1, 2]
      long_list = [10, 20, 30, 40]
      for a, b in zip(short_list, long_list):
          print(f"{a} - {b}")
      # Output: 1 - 10, 2 - 20 (stops after 2 pairs)
      
      # Creating dictionaries with zip()
      keys = ["name", "age", "city"]
      values = ["Alice", 30, "Paris"]
      person = dict(zip(keys, values))
      print(person)  # {'name': 'Alice', 'age': 30, 'city': 'Paris'}
      
      # range() - number sequences
      for i in range(5):
          print(i)  # 0, 1, 2, 3, 4
      
      for i in range(2, 8):
          print(i)  # 2, 3, 4, 5, 6, 7
      
      for i in range(0, 10, 2):
          print(i)  # 0, 2, 4, 6, 8
      
      # Converting to lists
      indices = list(enumerate(fruits))
      print(indices)  # [(0, 'apple'), (1, 'banana'), (2, 'orange')]
      
      pairs = list(zip(names, ages))
      print(pairs)    # [('Alice', 25), ('Bob', 30), ('Charlie', 35)]

  - question: "How do you write to files in Python?"
    answer: "Use open() with 'w' mode to write (overwrites) or 'a' mode to append. Always use the 'with' statement to ensure files are properly closed"
    code_example: |
      # Writing to a file (overwrites existing content)
      with open("example.txt", "w") as file:
          file.write("Hello, World!\n")
          file.write("This is a second line.\n")
          file.write("Third line here.")
      
      # Appending to a file (adds to existing content)
      with open("example.txt", "a") as file:
          file.write("\nThis line is appended.")
          file.write("\nAnother appended line.")
      
      # Writing multiple lines at once
      lines = ["First line\n", "Second line\n", "Third line\n"]
      with open("multiple_lines.txt", "w") as file:
          file.writelines(lines)
      
      # Writing data from variables
      name = "Alice"
      age = 30
      with open("person.txt", "w") as file:
          file.write(f"Name: {name}\n")
          file.write(f"Age: {age}\n")
      
      # Writing lists and data structures
      shopping_list = ["apples", "bananas", "oranges"]
      with open("shopping.txt", "w") as file:
          for item in shopping_list:
              file.write(f"- {item}\n")
      
      # Error handling for file writing
      try:
          with open("/protected/file.txt", "w") as file:
              file.write("This might fail")
      except PermissionError:
          print("Permission denied - cannot write to file")
      except FileNotFoundError:
          print("Directory does not exist")
      
      # Writing with different encodings
      with open("unicode.txt", "w", encoding="utf-8") as file:
          file.write("Hello, ‰∏ñÁïå! üåç\n")

  - question: "How do you read from files in Python?"
    answer: "Use open() with 'r' mode to read files. You can read the entire file with read(), line by line with a for loop, or all lines into a list with readlines()"
    code_example: |
      # Reading entire file as one string
      with open("example.txt", "r") as file:
          content = file.read()
          print(content)
      
      # Reading line by line (memory efficient for large files)
      with open("example.txt", "r") as file:
          for line in file:
              print(line.strip())  # Remove newline characters
      
      # Reading all lines into a list
      with open("example.txt", "r") as file:
          lines = file.readlines()
          print(lines)  # List with newline characters included
      
      # Reading first few lines only
      with open("example.txt", "r") as file:
          first_line = file.readline()
          second_line = file.readline()
          print(f"First: {first_line.strip()}")
          print(f"Second: {second_line.strip()}")
      
      # Reading and processing each line
      total_lines = 0
      with open("example.txt", "r") as file:
          for line in file:
              total_lines += 1
              if "important" in line.lower():
                  print(f"Found important line {total_lines}: {line.strip()}")
      
      # Safe file reading with error handling
      def read_file_safely(filename):
          try:
              with open(filename, "r") as file:
                  return file.read()
          except FileNotFoundError:
              print(f"File {filename} not found")
              return None
          except PermissionError:
              print(f"Permission denied to read {filename}")
              return None
      
      content = read_file_safely("data.txt")
      if content:
          print("File contents:", content)
      
      # Reading with different encodings
      with open("unicode.txt", "r", encoding="utf-8") as file:
          content = file.read()
          print(content)

  - question: "What are file modes and the 'with' statement in Python?"
    answer: "File modes specify how to open files: 'r' for reading, 'w' for writing, 'a' for appending. The 'with' statement automatically closes files and handles errors properly"
    code_example: |
      # Common file modes
      # "r" - read only (default mode)
      # "w" - write only (overwrites existing file)
      # "a" - append only (adds to end of file)
      # "r+" - read and write
      # "x" - exclusive creation (fails if file exists)
      
      # Using different modes
      with open("read_only.txt", "r") as file:
          content = file.read()
      
      with open("write_only.txt", "w") as file:
          file.write("This overwrites everything")
      
      with open("append_only.txt", "a") as file:
          file.write("This gets added to the end")
      
      # The 'with' statement (context manager)
      # Automatically closes file when done or if error occurs
      with open("safe_file.txt", "w") as file:
          file.write("This file will be closed automatically")
          # File is automatically closed here
      
      # Without 'with' statement (not recommended)
      file = open("manual.txt", "w")
      file.write("Must remember to close")
      file.close()  # Easy to forget!
      
      # 'with' handles errors automatically
      try:
          with open("data.txt", "r") as file:
              data = file.read()
              # Even if an error occurs here, file will be closed
              result = 1 / 0  # This causes an error
      except ZeroDivisionError:
          print("Error occurred, but file was still closed properly")
      
      # Binary modes for non-text files
      # "rb" - read binary
      # "wb" - write binary
      # "ab" - append binary
      
      # Working with binary files (images, etc.)
      with open("image.jpg", "rb") as file:
          binary_data = file.read()
      
      # Multiple files with nested 'with'
      with open("input.txt", "r") as infile:
          with open("output.txt", "w") as outfile:
              for line in infile:
                  outfile.write(line.upper())
      
      # File existence checking
      import os
      if os.path.exists("myfile.txt"):
          with open("myfile.txt", "r") as file:
              content = file.read()
      else:
          print("File does not exist")

  - question: "What are the different ways to import modules in Python?"
    answer: "You can import entire modules with 'import', specific items with 'from...import', use aliases with 'as', or import everything with '*' (not recommended)"
    code_example: |
      # Import entire module
      import math
      print(math.pi)                # 3.141592653589793
      print(math.sqrt(16))          # 4.0
      print(math.cos(0))            # 1.0
      
      # Import specific functions/variables
      from math import pi, sqrt, sin, cos
      print(pi)                     # 3.141592653589793
      print(sqrt(16))               # 4.0
      print(sin(pi/2))              # 1.0
      
      # Import with aliases (shorter names)
      import math as m
      print(m.pi)                   # 3.141592653589793
      print(m.factorial(5))         # 120
      
      # Import specific items with aliases
      from math import sqrt as square_root
      from math import pi as PI
      print(square_root(25))        # 5.0
      print(PI)                     # 3.141592653589793
      
      # Import everything (not recommended - can cause name conflicts)
      # from math import *
      # print(pi)  # Works but unclear where 'pi' comes from
      
      # Multiple imports on one line
      from datetime import date, time, datetime
      
      # Import submodules
      from os import path
      print(path.exists("myfile.txt"))
      
      # Conditional imports (advanced)
      try:
          import numpy as np
          has_numpy = True
      except ImportError:
          has_numpy = False
          print("NumPy not available")
      
      # Import at different locations
      def use_random():
          import random  # Import inside function
          return random.randint(1, 100)

  - question: "What are common built-in modules in Python?"
    answer: "Python has many useful built-in modules like math for mathematical functions, random for random numbers, datetime for dates/times, and os for operating system functions"
    code_example: |
      # Math module - mathematical functions
      import math
      print(math.sqrt(16))          # 4.0
      print(math.pi)                # 3.141592653589793
      print(math.factorial(5))      # 120
      print(math.ceil(4.2))         # 5 (round up)
      print(math.floor(4.8))        # 4 (round down)
      
      # Random module - random numbers and choices
      import random
      print(random.randint(1, 10))      # Random integer 1-10
      print(random.choice(['a', 'b', 'c']))  # Random choice from list
      print(random.random())            # Random float 0.0-1.0
      
      numbers = [1, 2, 3, 4, 5]
      random.shuffle(numbers)           # Shuffle list in place
      print(numbers)
      
      # Datetime module - dates and times
      import datetime
      now = datetime.datetime.now()
      print(now)                        # Current date and time
      
      today = datetime.date.today()
      print(today)                      # Current date
      
      birthday = datetime.date(1990, 5, 15)
      age = today - birthday
      print(f"Age: {age.days} days")
      
      # OS module - operating system functions
      import os
      print(os.getcwd())                # Current working directory
      print(os.listdir('.'))            # List files in current directory
      
      # Check if file/directory exists
      if os.path.exists('myfile.txt'):
          print("File exists")
      
      # Time module - time-related functions
      import time
      print(time.time())                # Current timestamp
      time.sleep(1)                     # Pause for 1 second
      
      # Collections module - specialized data structures
      from collections import Counter
      words = ['apple', 'banana', 'apple', 'orange', 'apple']
      count = Counter(words)
      print(count)                      # Counter({'apple': 3, 'banana': 1, 'orange': 1})

  - question: "How do you create and use custom modules in Python?"
    answer: "Create a custom module by saving Python code in a .py file, then import it like any other module. The file name becomes the module name"
    code_example: |
      # Create a file called 'my_utils.py' with this content:
      # 
      # def greet(name):
      #     """Greet a person by name"""
      #     return f"Hello, {name}!"
      # 
      # def calculate_area(length, width):
      #     """Calculate rectangle area"""
      #     return length * width
      # 
      # PI = 3.14159
      # 
      # class Calculator:
      #     def add(self, a, b):
      #         return a + b
      #     
      #     def multiply(self, a, b):
      #         return a * b
      
      # Then import and use your custom module:
      import my_utils
      
      # Use functions from your module
      message = my_utils.greet("Alice")
      print(message)                    # "Hello, Alice!"
      
      area = my_utils.calculate_area(10, 5)
      print(f"Area: {area}")            # "Area: 50"
      
      # Use variables from your module
      print(f"PI value: {my_utils.PI}") # "PI value: 3.14159"
      
      # Use classes from your module
      calc = my_utils.Calculator()
      result = calc.add(5, 3)
      print(f"5 + 3 = {result}")        # "5 + 3 = 8"
      
      # Import specific items from your module
      from my_utils import greet, calculate_area
      print(greet("Bob"))               # "Hello, Bob!"
      print(calculate_area(8, 6))       # 48
      
      # Import with alias
      import my_utils as utils
      print(utils.greet("Charlie"))     # "Hello, Charlie!"
      
      # Module structure best practices:
      # my_package/
      #   __init__.py       # Makes it a package
      #   core.py           # Core functionality
      #   helpers.py        # Helper functions
      #   constants.py      # Constants and configuration
      
      # Then import like:
      # from my_package import core
      # from my_package.helpers import some_function
      
      # Check if module is being run directly
      # Add this to your module:
      # if __name__ == "__main__":
      #     # This only runs when file is executed directly
      #     print("Testing the module...")
      #     print(greet("Test User"))

  - question: "What is JSON and what is it used for?"
    answer: "JSON (JavaScript Object Notation) is a lightweight, text-based data format for storing and exchanging data. It's language-independent and commonly used for APIs, configuration files, and data storage"
    code_example: |
      # JSON is a text format that looks like this:
      # {
      #   "name": "Alice",
      #   "age": 30,
      #   "city": "New York",
      #   "hobbies": ["reading", "coding", "hiking"],
      #   "is_student": false,
      #   "address": {
      #     "street": "123 Main St",
      #     "zipcode": "10001"
      #   }
      # }
      
      # JSON supports these data types:
      # - Strings (must use double quotes)
      # - Numbers (integers and floats)
      # - Booleans (true/false, lowercase)
      # - null (equivalent to Python's None)
      # - Arrays (like Python lists)
      # - Objects (like Python dictionaries)
      
      # Common uses of JSON:
      # 1. Web APIs - sending data between client and server
      # 2. Configuration files - storing app settings
      # 3. Data storage - lightweight alternative to databases
      # 4. Data exchange - between different programming languages
      # 5. NoSQL databases - MongoDB stores data in JSON-like format
      
      # JSON vs Python comparison:
      # JSON           Python
      # true/false  -> True/False
      # null        -> None
      # "string"    -> "string" or 'string'
      # [1,2,3]     -> [1, 2, 3]
      # {"key":val} -> {"key": val}
      
      # Example: API response
      api_response = """
      {
        "status": "success",
        "data": {
          "users": [
            {"id": 1, "name": "Alice"},
            {"id": 2, "name": "Bob"}
          ]
        },
        "message": "Users retrieved successfully"
      }
      """

  - question: "What is json.loads() and how do you use it?"
    answer: "json.loads() converts a JSON string into a Python object (dictionary, list, etc.). The 's' stands for 'string' - it loads JSON from a string"
    code_example: |
      import json
      
      # Convert JSON string to Python object
      json_string = '{"name": "Alice", "age": 30, "city": "New York"}'
      python_dict = json.loads(json_string)
      print(python_dict)          # {'name': 'Alice', 'age': 30, 'city': 'New York'}
      print(type(python_dict))    # <class 'dict'>
      
      # Access the data like a normal Python dictionary
      print(python_dict["name"])  # Alice
      print(python_dict["age"])   # 30
      
      # JSON array becomes Python list
      json_array = '["apple", "banana", "orange"]'
      python_list = json.loads(json_array)
      print(python_list)          # ['apple', 'banana', 'orange']
      print(type(python_list))    # <class 'list'>
      
      # Complex nested JSON
      complex_json = '''
      {
        "user": {
          "name": "Bob",
          "preferences": {
            "theme": "dark",
            "notifications": true
          },
          "scores": [85, 92, 78]
        }
      }
      '''
      data = json.loads(complex_json)
      print(data["user"]["name"])                    # Bob
      print(data["user"]["preferences"]["theme"])    # dark
      print(data["user"]["scores"][0])               # 85
      
      # Error handling for invalid JSON
      invalid_json = '{"name": "Alice", "age":}'  # Missing value
      try:
          result = json.loads(invalid_json)
      except json.JSONDecodeError as e:
          print(f"Invalid JSON: {e}")
      
      # Boolean and null conversion
      json_data = '{"active": true, "deleted": false, "data": null}'
      parsed = json.loads(json_data)
      print(parsed["active"])     # True (Python boolean)
      print(parsed["deleted"])    # False (Python boolean)
      print(parsed["data"])       # None (Python None)

  - question: "What is json.dumps() and how do you use it?"
    answer: "json.dumps() converts a Python object into a JSON string. The 's' stands for 'string' - it dumps Python data to a string format"
    code_example: |
      import json
      
      # Convert Python dictionary to JSON string
      python_dict = {"name": "Alice", "age": 30, "city": "New York"}
      json_string = json.dumps(python_dict)
      print(json_string)          # {"name": "Alice", "age": 30, "city": "New York"}
      print(type(json_string))    # <class 'str'>
      
      # Convert Python list to JSON string
      python_list = ["apple", "banana", "orange"]
      json_array = json.dumps(python_list)
      print(json_array)           # ["apple", "banana", "orange"]
      
      # Complex nested data
      user_data = {
          "user": {
              "name": "Bob",
              "preferences": {
                  "theme": "dark",
                  "notifications": True
              },
              "scores": [85, 92, 78],
              "active": True,
              "notes": None
          }
      }
      json_output = json.dumps(user_data)
      print(json_output)  # All Python values converted to JSON equivalents
      
      # Pretty printing with indentation
      pretty_json = json.dumps(user_data, indent=2)
      print(pretty_json)
      # Output:
      # {
      #   "user": {
      #     "name": "Bob",
      #     "preferences": {
      #       "theme": "dark",
      #       "notifications": true
      #     },
      #     "scores": [85, 92, 78],
      #     "active": true,
      #     "notes": null
      #   }
      # }
      
      # Other useful options
      compact_json = json.dumps(user_data, separators=(',', ':'))  # No spaces
      sorted_json = json.dumps(user_data, sort_keys=True)          # Sort keys alphabetically
      
      # Python to JSON type conversion:
      # dict -> object {}
      # list/tuple -> array []
      # str -> string ""
      # int/float -> number
      # True/False -> true/false
      # None -> null

  - question: "What is json.load() and how do you use it?"
    answer: "json.load() reads JSON data directly from a file object and converts it to Python objects. It's used for loading JSON from files"
    code_example: |
      import json
      
      # First, let's create a JSON file to read from
      data_to_save = {
          "users": [
              {"id": 1, "name": "Alice", "email": "alice@example.com"},
              {"id": 2, "name": "Bob", "email": "bob@example.com"}
          ],
          "settings": {
              "version": "1.0",
              "debug": False
          }
      }
      
      # Save data to file first (we'll learn json.dump() next)
      with open("data.json", "w") as file:
          json.dump(data_to_save, file)
      
      # Now read JSON data from file using json.load()
      with open("data.json", "r") as file:
          loaded_data = json.load(file)
      
      print(type(loaded_data))    # <class 'dict'>
      print(loaded_data["users"][0]["name"])    # Alice
      print(loaded_data["settings"]["version"]) # 1.0
      
      # Reading configuration files
      # config.json might contain:
      # {
      #   "database": {
      #     "host": "localhost",
      #     "port": 5432,
      #     "name": "myapp"
      #   },
      #   "api_keys": {
      #     "stripe": "sk_test_...",
      #     "sendgrid": "SG...."
      #   }
      # }
      
      try:
          with open("config.json", "r") as config_file:
              config = json.load(config_file)
              db_host = config["database"]["host"]
              db_port = config["database"]["port"]
              print(f"Connecting to {db_host}:{db_port}")
      except FileNotFoundError:
          print("Config file not found")
      except json.JSONDecodeError as e:
          print(f"Invalid JSON in config file: {e}")
      
      # Reading API responses saved to files
      with open("api_response.json", "r") as api_file:
          try:
              response_data = json.load(api_file)
              if response_data["status"] == "success":
                  users = response_data["data"]["users"]
                  for user in users:
                      print(f"User: {user['name']}")
          except KeyError as e:
              print(f"Missing key in response: {e}")
      
      # Remember: json.load() is for FILES, json.loads() is for STRINGS

  - question: "What is json.dump() and how do you use it?"
    answer: "json.dump() writes Python objects directly to a file as JSON. It's used for saving Python data to JSON files"
    code_example: |
      import json
      
      # Python data to save
      student_data = {
          "students": [
              {
                  "id": 1,
                  "name": "Alice Johnson",
                  "grades": [85, 92, 78, 96],
                  "active": True,
                  "graduation_date": None
              },
              {
                  "id": 2,
                  "name": "Bob Smith",
                  "grades": [79, 88, 91, 85],
                  "active": True,
                  "graduation_date": "2024-06-15"
              }
          ],
          "course": "Python Programming",
          "semester": "Fall 2023"
      }
      
      # Save data to JSON file using json.dump()
      with open("students.json", "w") as file:
          json.dump(student_data, file)
      
      # Save with pretty formatting (indented)
      with open("students_pretty.json", "w") as file:
          json.dump(student_data, file, indent=2)
      
      # Save with sorted keys
      with open("students_sorted.json", "w") as file:
          json.dump(student_data, file, indent=2, sort_keys=True)
      
      # Saving configuration files
      app_config = {
          "app_name": "My Web App",
          "version": "2.1.0",
          "database": {
              "host": "localhost",
              "port": 5432,
              "name": "webapp_db"
          },
          "features": {
              "user_registration": True,
              "email_notifications": True,
              "analytics": False
          },
          "supported_languages": ["en", "es", "fr"]
      }
      
      with open("app_config.json", "w") as config_file:
          json.dump(app_config, config_file, indent=4)
      
      # Appending to existing JSON (requires reading first)
      # Read existing data
      try:
          with open("students.json", "r") as file:
              existing_data = json.load(file)
      except FileNotFoundError:
          existing_data = {"students": []}
      
      # Add new student
      new_student = {
          "id": 3,
          "name": "Charlie Brown",
          "grades": [91, 87, 94],
          "active": True,
          "graduation_date": None
      }
      existing_data["students"].append(new_student)
      
      # Save updated data
      with open("students.json", "w") as file:
          json.dump(existing_data, file, indent=2)
      
      # Error handling for non-serializable objects
      import datetime
      
      problematic_data = {
          "name": "Test",
          "date": datetime.datetime.now()  # This can't be serialized to JSON!
      }
      
      try:
          with open("problem.json", "w") as file:
              json.dump(problematic_data, file)
      except TypeError as e:
          print(f"Cannot serialize to JSON: {e}")

  - question: "What's the difference between json.load/json.loads and json.dump/json.dumps?"
    answer: "The difference is the source/destination: load/dump work with FILES, while loads/dumps work with STRINGS. The 's' suffix means 'string'"
    code_example: |
      import json
      
      # Sample data for examples
      data = {"name": "Alice", "age": 30, "hobbies": ["reading", "coding"]}
      
      # ============================================
      # WRITING/SERIALIZING (Python -> JSON)
      # ============================================
      
      # json.dumps() - Dump to String
      json_string = json.dumps(data)
      print(f"json.dumps() result: {json_string}")
      print(f"Type: {type(json_string)}")  # <class 'str'>
      
      # json.dump() - Dump to File
      with open("output.json", "w") as file:
          json.dump(data, file)
      print("json.dump() saved data to output.json")
      
      # ============================================
      # READING/DESERIALIZING (JSON -> Python)
      # ============================================
      
      # json.loads() - Load from String
      json_text = '{"name": "Bob", "age": 25}'
      parsed_data = json.loads(json_text)
      print(f"json.loads() result: {parsed_data}")
      print(f"Type: {type(parsed_data)}")  # <class 'dict'>
      
      # json.load() - Load from File
      with open("output.json", "r") as file:
          file_data = json.load(file)
      print(f"json.load() result: {file_data}")
      
      # ============================================
      # MEMORY: String vs File operations
      # ============================================
      
      # When you have JSON as a string (from API, user input, etc.)
      api_response = '{"status": "success", "users": [{"id": 1, "name": "Alice"}]}'
      users = json.loads(api_response)  # Use loads() for strings
      
      # When you want to save to file
      with open("users.json", "w") as f:
          json.dump(users, f)  # Use dump() for files
      
      # When you want to read from file
      with open("users.json", "r") as f:
          loaded_users = json.load(f)  # Use load() for files
      
      # When you want to convert to string (for sending over network)
      users_string = json.dumps(loaded_users)  # Use dumps() for strings
      
      # ============================================
      # Common use cases
      # ============================================
      
      # 1. API communication (strings)
      def send_api_request(data):
          json_payload = json.dumps(data)  # Convert to JSON string
          # send json_payload to API...
          return json_payload
      
      def process_api_response(response_text):
          return json.loads(response_text)  # Parse JSON string
      
      # 2. File storage (files)
      def save_settings(settings):
          with open("settings.json", "w") as f:
              json.dump(settings, f)  # Save to file
      
      def load_settings():
          with open("settings.json", "r") as f:
              return json.load(f)  # Load from file
      
      # Remember: 's' = string, no 's' = file

  - question: "What is truthiness and falsiness in Python?"
    answer: "Truthiness refers to how Python evaluates values in boolean contexts. Some values are 'falsy' (evaluate to False) while others are 'truthy' (evaluate to True)"
    code_example: |
      # Falsy values (evaluate to False)
      print(bool(False))            # False
      print(bool(None))             # False
      print(bool(0))                # False
      print(bool(0.0))              # False
      print(bool(""))               # False (empty string)
      print(bool([]))               # False (empty list)
      print(bool({}))               # False (empty dict)
      print(bool(()))               # False (empty tuple)
      print(bool(set()))            # False (empty set)
      
      # Truthy values (evaluate to True)
      print(bool(True))             # True
      print(bool(1))                # True
      print(bool(-1))               # True (any non-zero number)
      print(bool("hello"))          # True (non-empty string)
      print(bool([1, 2, 3]))        # True (non-empty list)
      print(bool({"a": 1}))         # True (non-empty dict)
      
      # Using in conditions
      items = []
      if items:                     # False because list is empty
          print("Has items")
      else:
          print("No items")         # This will print
      
      name = ""
      if name:                      # False because string is empty
          print(f"Hello, {name}")
      else:
          print("Please enter a name")
      
      # Practical usage
      def process_data(data):
          if not data:              # Check if data is falsy
              return "No data provided"
          return f"Processing {len(data)} items"

  - question: "What is None in Python and how do you use it?"
    answer: "None is Python's null value, representing the absence of a value. It's commonly used as a default value or to indicate 'no result'"
    code_example: |
      # None is a special constant
      result = None
      print(type(None))             # <class 'NoneType'>
      
      # Functions return None by default
      def no_return():
          print("This function doesn't return anything")
      
      result = no_return()
      print(result)                 # None
      
      # Checking for None
      if result is None:
          print("Result is None")
      
      # Don't use == with None, use 'is'
      if result == None:            # Works but not recommended
          print("Result is None")
      
      if result is None:            # Correct way
          print("Result is None")
      
      # None as default parameter
      def greet(name=None):
          if name is None:
              return "Hello, stranger!"
          return f"Hello, {name}!"
      
      print(greet())                # "Hello, stranger!"
      print(greet("Alice"))         # "Hello, Alice!"
      
      # None in data structures
      data = [1, 2, None, 4, 5]
      
      # Filter out None values
      clean_data = [x for x in data if x is not None]
      print(clean_data)             # [1, 2, 4, 5]
      
      # None vs empty values
      print(None == "")             # False
      print(None == 0)              # False
      print(None == [])             # False

  - question: "What is string concatenation and how do you combine strings with the + operator?"
    answer: "String concatenation is joining two or more strings together. Use the + operator to combine strings. When concatenating with numbers, convert them to strings first using str()"
    code_example: |
      # Basic string concatenation with +
      first_name = "John"
      last_name = "Smith"
      full_name = first_name + " " + last_name
      print(full_name)                    # "John Smith"
      
      # Multiple concatenations
      greeting = "Hello, " + "my name is " + first_name
      print(greeting)                     # "Hello, my name is John"
      
      # Concatenating strings with numbers (convert first)
      age = 25
      message = "I am " + str(age) + " years old"
      print(message)                      # "I am 25 years old"
      
      # Building longer strings
      city = "New York"
      country = "USA"
      location = first_name + " lives in " + city + ", " + country
      print(location)                     # "John lives in New York, USA"
      
      # Adding to existing string
      base_message = "Welcome"
      complete_message = base_message + ", " + first_name + "!"
      print(complete_message)             # "Welcome, John!"
      
      # Common mistake - can't concatenate string and number directly
      # message = "Age: " + age           # ERROR! TypeError
      message = "Age: " + str(age)        # CORRECT! Convert number to string

  - question: "What are f-strings and how do you use them for string formatting?"
    answer: "F-strings (formatted string literals) let you embed variables and expressions directly in strings using curly braces {}. They're the modern, preferred way to format strings in Python"
    code_example: |
      # Basic f-string usage
      name = "Alice"
      age = 30
      message = f"Hello, {name}! You are {age} years old."
      print(message)                      # "Hello, Alice! You are 30 years old."
      
      # f-strings with expressions
      x = 10
      y = 5
      result = f"The sum of {x} and {y} is {x + y}"
      print(result)                       # "The sum of 10 and 5 is 15"
      
      # f-strings with formatting
      price = 19.99
      formatted = f"Price: ${price:.2f}"
      print(formatted)                    # "Price: $19.99"
      
      # Multi-line f-strings
      student = "Bob"
      grade = 87.5
      report = f"""
      Student Report:
      Name: {student}
      Grade: {grade}%
      Status: {'Pass' if grade >= 70 else 'Fail'}
      """
      print(report)
      
      # f-strings vs concatenation (much cleaner!)
      # Concatenation: "Hello, " + name + "! You scored " + str(grade) + "%"
      # f-string: f"Hello, {name}! You scored {grade}%"

  - question: "What is the .format() method and how do you use it for string formatting?"
    answer: "The .format() method is an older way to format strings by using placeholders {} in the string and passing values as arguments. It's still widely used in existing code"
    code_example: |
      # Basic .format() usage
      name = "Charlie"
      age = 25
      message = "Hello, {}! You are {} years old.".format(name, age)
      print(message)                      # "Hello, Charlie! You are 25 years old."
      
      # Named placeholders
      template = "Hello, {name}! You are {age} years old."
      message = template.format(name="Diana", age=28)
      print(message)                      # "Hello, Diana! You are 28 years old."
      
      # Positional arguments
      template = "The {0} brown {1} jumps over the {2}"
      sentence = template.format("quick", "fox", "fence")
      print(sentence)                     # "The quick brown fox jumps over the fence"
      
      # Formatting numbers
      price = 19.99
      formatted = "Price: ${:.2f}".format(price)
      print(formatted)                    # "Price: $19.99"
      
      # Multiple uses of same value
      template = "{name} likes {food}. {name} eats {food} every day."
      message = template.format(name="Alice", food="pizza")
      print(message)                      # "Alice likes pizza. Alice eats pizza every day."
      
      # With calculations
      x = 10
      y = 5
      result = "The sum of {} and {} is {}".format(x, y, x + y)
      print(result)                       # "The sum of 10 and 5 is 15"

  - question: "What is the .join() method and how do you use it to combine multiple strings?"
    answer: "The .join() method efficiently combines a list of strings into a single string, using a specified separator. It's much more efficient than using + for multiple strings"
    code_example: |
      # Basic .join() usage
      words = ["Python", "is", "awesome"]
      sentence = " ".join(words)
      print(sentence)                     # "Python is awesome"
      
      # Different separators
      fruits = ["apple", "banana", "orange"]
      comma_separated = ", ".join(fruits)
      print(comma_separated)              # "apple, banana, orange"
      
      dash_separated = "-".join(fruits)
      print(dash_separated)               # "apple-banana-orange"
      
      # No separator (empty string)
      letters = ["H", "e", "l", "l", "o"]
      word = "".join(letters)
      print(word)                         # "Hello"
      
      # Join with newlines
      lines = ["First line", "Second line", "Third line"]
      text = "\n".join(lines)
      print(text)
      # Output:
      # First line
      # Second line
      # Third line
      
      # Why .join() is better than + for multiple strings
      # Inefficient way:
      items = ["a", "b", "c", "d", "e"]
      result = ""
      for item in items:
          result += item + ", "
      result = result.rstrip(", ")        # Remove last comma
      
      # Efficient way:
      result = ", ".join(items)
      print(result)                       # "a, b, c, d, e"
      
      # Converting numbers to strings first
      numbers = [1, 2, 3, 4, 5]
      number_strings = [str(n) for n in numbers]
      result = "-".join(number_strings)
      print(result)                       # "1-2-3-4-5"

  - question: "What are type hints in Python and how do you use them for basic annotations?"
    answer: "Type hints provide optional static type information to specify what types variables and functions should use. They help with code documentation and IDE support"
    code_example: |
      # Basic variable type hints
      name: str = "Alice"
      age: int = 30
      height: float = 5.6
      is_student: bool = True
      
      # Function type hints
      def greet(name: str, age: int) -> str:
          return f"Hello {name}, you are {age} years old"
      
      def add_numbers(a: int, b: int) -> int:
          return a + b
      
      def calculate_area(length: float, width: float) -> float:
          return length * width
      
      # List and dictionary type hints (Python 3.9+)
      numbers: list[int] = [1, 2, 3, 4, 5]
      grades: dict[str, int] = {"Alice": 85, "Bob": 90}
      coordinates: tuple[int, int] = (10, 20)
      
      # Function with no return value
      def print_message(message: str) -> None:
          print(message)
      
      # Optional values (can be None)
      def find_student(student_id: int) -> str | None:
          if student_id > 0:
              return f"Student {student_id}"
          return None
      
      # Multiple possible types
      def process_input(data: int | str) -> str:
          return str(data)
      
      # Class with type hints
      class Student:
          def __init__(self, name: str, age: int) -> None:
              self.name: str = name
              self.age: int = age
          
          def get_info(self) -> str:
              return f"{self.name} is {self.age} years old"