flashcards:
  - question: "What is a Python list comprehension?"
    answer: "A concise way to create lists using a single line of code with optional filtering"
    code_example: |
      # Traditional approach
      squares = []
      for x in range(10):
          if x % 2 == 0:
              squares.append(x**2)
      
      # List comprehension
      squares = [x**2 for x in range(10) if x % 2 == 0]

  - question: "What is the difference between == and is in Python?"
    answer: "== compares values for equality, while is compares object identity (memory location)"
    code_example: |
      a = [1, 2, 3]
      b = [1, 2, 3]
      c = a
      
      print(a == b)  # True (same values)
      print(a is b)  # False (different objects)
      print(a is c)  # True (same object)

  - question: "What is a Python decorator?"
    answer: "A function that wraps another function to extend or modify its behavior without permanently modifying it"
    code_example: |
      def my_decorator(func):
          def wrapper(*args, **kwargs):
              print("Before function execution")
              result = func(*args, **kwargs)
              print("After function execution")
              return result
          return wrapper

      @my_decorator
      def say_hello(name):
          print(f"Hello, {name}!")

      say_hello("Alice")

  - question: "What is the Global Interpreter Lock (GIL)?"
    answer: "A mutex that prevents multiple native threads from executing Python bytecode simultaneously"
    code_example: |
      import threading
      import time

      def cpu_bound_task():
          # This won't run in parallel due to GIL
          count = 0
          for i in range(1000000):
              count += 1
          return count

      # Multiple threads won't speed this up
      threads = []
      for i in range(4):
          t = threading.Thread(target=cpu_bound_task)
          threads.append(t)
          t.start()

  - question: "What is a Python context manager?"
    answer: "An object that defines what happens when entering and exiting a 'with' statement"
    code_example: |
      # Built-in context manager
      with open('file.txt', 'r') as f:
          content = f.read()
      # File is automatically closed

      # Custom context manager
      class Timer:
          def __enter__(self):
              self.start = time.time()
              return self
          
          def __exit__(self, exc_type, exc_val, exc_tb):
              self.end = time.time()
              print(f"Elapsed: {self.end - self.start:.2f}s")

      with Timer():
          time.sleep(1)

  - question: "What are Python generators?"
    answer: "Functions that return an iterator object which produces values on-demand using yield"
    code_example: |
      # Generator function
      def fibonacci():
          a, b = 0, 1
          while True:
              yield a
              a, b = b, a + b

      # Generator expression
      squares = (x**2 for x in range(10))

      # Usage
      fib = fibonacci()
      print(next(fib))  # 0
      print(next(fib))  # 1
      print(next(fib))  # 1

  - question: "What is the difference between *args and **kwargs?"
    answer: "*args collects positional arguments into a tuple, **kwargs collects keyword arguments into a dictionary"
    code_example: |
      def flexible_function(*args, **kwargs):
          print("Positional args:", args)
          print("Keyword args:", kwargs)

      flexible_function(1, 2, 3, name="Alice", age=30)
      # Output:
      # Positional args: (1, 2, 3)
      # Keyword args: {'name': 'Alice', 'age': 30}

      # Unpacking arguments
      def greet(name, age):
          return f"Hello {name}, you are {age} years old"

      person = ("Bob", 25)
      info = {"name": "Charlie", "age": 35}
      
      print(greet(*person))      # Unpack tuple
      print(greet(**info))       # Unpack dictionary

  - question: "What is the difference between mutable and immutable objects in Python?"
    answer: "Mutable objects can be changed after creation (lists, dicts, sets), while immutable objects cannot be changed (strings, tuples, integers)"
    code_example: |
      # Mutable objects
      my_list = [1, 2, 3]
      my_list.append(4)  # Modifies the original list
      print(my_list)     # [1, 2, 3, 4]
      
      my_dict = {"a": 1}
      my_dict["b"] = 2   # Modifies the original dict
      print(my_dict)     # {"a": 1, "b": 2}
      
      # Immutable objects
      my_string = "hello"
      new_string = my_string + " world"  # Creates new string
      print(my_string)    # "hello" (unchanged)
      print(new_string)   # "hello world"
      
      my_tuple = (1, 2, 3)
      # my_tuple[0] = 5   # This would raise TypeError

  - question: "What is a lambda function in Python?"
    answer: "A small anonymous function defined with the lambda keyword, used for simple one-line functions"
    code_example: |
      # Lambda function
      square = lambda x: x**2
      print(square(5))  # 25
      
      # Used with map, filter, sorted
      numbers = [1, 2, 3, 4, 5]
      squares = list(map(lambda x: x**2, numbers))
      evens = list(filter(lambda x: x % 2 == 0, numbers))
      
      # Sorting with lambda
      students = [('Alice', 85), ('Bob', 90), ('Charlie', 78)]
      sorted_by_grade = sorted(students, key=lambda student: student[1])
      print(sorted_by_grade)  # [('Charlie', 78), ('Alice', 85), ('Bob', 90)]

  - question: "What are Python's magic methods (dunder methods)?"
    answer: "Special methods with double underscores that allow objects to interact with Python's built-in functions and operators"
    code_example: |
      class Point:
          def __init__(self, x, y):
              self.x = x
              self.y = y
          
          def __str__(self):
              return f"Point({self.x}, {self.y})"
          
          def __repr__(self):
              return f"Point(x={self.x}, y={self.y})"
          
          def __add__(self, other):
              return Point(self.x + other.x, self.y + other.y)
          
          def __eq__(self, other):
              return self.x == other.x and self.y == other.y
          
          def __len__(self):
              return int((self.x**2 + self.y**2)**0.5)
      
      p1 = Point(1, 2)
      p2 = Point(3, 4)
      print(str(p1))     # Point(1, 2)
      print(p1 + p2)     # Point(4, 6)
      print(p1 == p2)    # False

  - question: "What is Python's self parameter in class methods?"
    answer: "A reference to the current instance of the class, allowing access to instance variables and methods"
    code_example: |
      class Dog:
          def __init__(self, name, breed):
              self.name = name      # Instance variable
              self.breed = breed    # Instance variable
          
          def bark(self):
              return f"{self.name} says Woof!"
          
          def get_info(self):
              return f"{self.name} is a {self.breed}"
          
          def change_name(self, new_name):
              self.name = new_name  # Modify instance variable
      
      my_dog = Dog("Buddy", "Golden Retriever")
      print(my_dog.bark())        # Buddy says Woof!
      print(my_dog.get_info())    # Buddy is a Golden Retriever
      my_dog.change_name("Max")
      print(my_dog.bark())        # Max says Woof!

  - question: "What is the difference between @staticmethod and @classmethod decorators?"
    answer: "@staticmethod doesn't receive any automatic arguments, @classmethod receives the class as first argument (cls)"
    code_example: |
      class MathUtils:
          pi = 3.14159
          
          @staticmethod
          def add(x, y):
              # No access to class or instance
              return x + y
          
          @classmethod
          def get_pi(cls):
              # Access to class variables and methods
              return cls.pi
          
          @classmethod
          def from_string(cls, math_string):
              # Alternative constructor
              x, y = map(int, math_string.split('+'))
              return cls.add(x, y)
      
      # Usage
      print(MathUtils.add(5, 3))              # 8
      print(MathUtils.get_pi())               # 3.14159
      print(MathUtils.from_string("10+20"))   # 30

  - question: "What is list slicing in Python?"
    answer: "A way to extract a portion of a list using [start:stop:step] syntax"
    code_example: |
      numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
      
      # Basic slicing
      print(numbers[2:7])     # [2, 3, 4, 5, 6]
      print(numbers[:5])      # [0, 1, 2, 3, 4]
      print(numbers[5:])      # [5, 6, 7, 8, 9]
      print(numbers[:])       # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] (copy)
      
      # Step slicing
      print(numbers[::2])     # [0, 2, 4, 6, 8] (every 2nd element)
      print(numbers[1::2])    # [1, 3, 5, 7, 9] (every 2nd starting from 1)
      print(numbers[::-1])    # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] (reverse)
      
      # Negative indices
      print(numbers[-3:])     # [7, 8, 9] (last 3 elements)
      print(numbers[:-2])     # [0, 1, 2, 3, 4, 5, 6, 7] (all but last 2)

  - question: "What are Python sets and how do they differ from lists?"
    answer: "Sets are unordered collections of unique elements that support mathematical set operations"
    code_example: |
      # Creating sets
      fruits = {"apple", "banana", "orange"}
      numbers = set([1, 2, 3, 2, 1])  # {1, 2, 3} - duplicates removed
      
      # Set operations
      set1 = {1, 2, 3, 4}
      set2 = {3, 4, 5, 6}
      
      print(set1.union(set2))         # {1, 2, 3, 4, 5, 6}
      print(set1.intersection(set2))  # {3, 4}
      print(set1.difference(set2))    # {1, 2}
      print(set1.symmetric_difference(set2))  # {1, 2, 5, 6}
      
      # Set methods
      fruits.add("grape")
      fruits.remove("banana")  # KeyError if not found
      fruits.discard("kiwi")   # No error if not found
      
      # Membership testing (very fast)
      print("apple" in fruits)  # True

  - question: "What is exception handling in Python and how does try/except work?"
    answer: "Exception handling allows you to catch and handle errors gracefully using try/except/finally blocks"
    code_example: |
      # Basic exception handling
      try:
          result = 10 / 0
      except ZeroDivisionError:
          print("Cannot divide by zero!")
      except Exception as e:
          print(f"An error occurred: {e}")
      else:
          print("No exceptions occurred")
      finally:
          print("This always executes")
      
      # Multiple exception types
      try:
          value = int(input("Enter a number: "))
          result = 100 / value
      except (ValueError, TypeError):
          print("Invalid input type")
      except ZeroDivisionError:
          print("Cannot divide by zero")
      
      # Raising custom exceptions
      def validate_age(age):
          if age < 0:
              raise ValueError("Age cannot be negative")
          if age > 150:
              raise ValueError("Age seems unrealistic")
          return age